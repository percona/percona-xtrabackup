#
# Bug#34402003: HYPERGRAPH BUG: Offload issue with execute statement.
#
CREATE TABLE t1(a INT);
CREATE TABLE t2(a INT);
CREATE TABLE t3(a INT);
INSERT INTO t1 VALUES (1),(2),(5);
INSERT INTO t2 VALUES (2);
INSERT INTO t3 VALUES (3);
ANALYZE TABLE t1, t2, t3;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
test.t3	analyze	status	OK
SET optimizer_trace='enabled=on';
PREPARE stmt FROM "EXPLAIN FORMAT=tree SELECT * FROM t1 LEFT JOIN t2 ON t1.a=t2.a JOIN t3 ON t1.a=5";
EXECUTE stmt;
EXPLAIN
-> Inner hash join (no condition)  (rows=0.3)
    -> Table scan on t3  (rows=1)
    -> Hash
        -> Left hash join (no condition), extra conditions: (t1.a = 5)  (rows=0.3)
            -> Filter: (t1.a = 5)  (rows=0.3)
                -> Table scan on t1  (rows=3)
            -> Hash
                -> Filter: (t2.a = 5)  (rows=0.1)
                    -> Table scan on t2  (rows=1)

SELECT
IF(TRACE LIKE '%Left join [companion set %] (extra join condition = (t1.a = 5) AND (t2.a = 5))%',
'OK', TRACE)
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;
IF(TRACE LIKE '%Left join [companion set %] (extra join condition = (t1.a = 5) AND (t2.a = 5))%',
'OK', TRACE)
OK
PREPARE stmt FROM "SELECT * FROM t1 LEFT JOIN t2 ON t1.a=t2.a JOIN t3 ON t1.a=5";
EXECUTE stmt;
a	a	a
5	NULL	3
SET optimizer_trace="enabled=off";
DROP TABLE t1,t2,t3;
CREATE TABLE t0 (a0 INTEGER);
CREATE TABLE t1 (a1 INTEGER);
CREATE TABLE t2 (a2 INTEGER);
CREATE TABLE t3 (a3 INTEGER);
INSERT INTO t0 VALUES (0),(1);
INSERT INTO t1 VALUES (0),(1);
INSERT INTO t2 VALUES (1);
INSERT INTO t3 VALUES (1);
ANALYZE TABLE t0, t1, t2, t3;
Table	Op	Msg_type	Msg_text
test.t0	analyze	status	OK
test.t1	analyze	status	OK
test.t2	analyze	status	OK
test.t3	analyze	status	OK
EXPLAIN FORMAT=tree SELECT * FROM t0, t1 LEFT JOIN (t2,t3) ON a1=5 WHERE a0=a1 AND a0=1;
EXPLAIN
-> Left hash join (no condition), extra conditions: false  (rows=0.04)
    -> Inner hash join (no condition)  (rows=0.04)
        -> Filter: (t0.a0 = 1)  (rows=0.2)
            -> Table scan on t0  (rows=2)
        -> Hash
            -> Filter: (t1.a1 = 1)  (rows=0.2)
                -> Table scan on t1  (rows=2)
    -> Hash
        -> Zero rows (Join condition rejects all rows)  (rows=0)

SELECT * FROM t0, t1 LEFT JOIN (t2,t3) ON a1=5 WHERE a0=a1 AND a0=1;
a0	a1	a2	a3
1	1	NULL	NULL
DROP TABLE t0,t1,t2,t3;
#
# Bug#34401789: Enable constant propagation in conditions
#               for hypergraph optimizer
#
CREATE TABLE t1 (f1 INTEGER);
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
EXPLAIN FORMAT=tree
SELECT f1 FROM t1 GROUP BY f1 HAVING f1 = 10 AND f1 <> 11;
EXPLAIN
-> Filter: (t1.f1 = 10)  (rows=0.1)
    -> Group (no aggregates)  (rows=1)
        -> Sort: t1.f1  (rows=1)
            -> Table scan on t1  (rows=1)

DROP TABLE t1;
#
# Bug#34080394: Hypergraph Offload issue : Problem in
#               ExtractRequiredItemsForFilter.
#
CREATE TABLE t1 (f1 YEAR);
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
EXPLAIN FORMAT=tree SELECT * FROM t1 WHERE f1 = 1 AND f1 <> 11;
EXPLAIN
-> Filter: (t1.f1 = 2001)  (rows=0.1)
    -> Table scan on t1  (rows=1)

DROP TABLE t1;
#
# Bug#34504697: Hypergraph: Assertion
#               `!(used_tabs & (~read_tables & ~filter_for_table))'
#               failed
#
CREATE TABLE t1 (f1 INTEGER);
SELECT 1
FROM t1 LEFT JOIN (SELECT t2.*
FROM (t1 AS t2 INNER JOIN t1 AS t3 ON (t3.f1 = t2.f1))
WHERE (t3.f1 <> 1 OR t2.f1 > t2.f1)) AS dt
ON (t1.f1 = dt.f1);
1
DROP TABLE t1;
#
# Bug#34503695:Hypergraph: mysqld crash-signal 11
#              -CommonSubexpressionElimination
#
CREATE TABLE t1 (f1 INTEGER);
SELECT * FROM t1
WHERE t1.f1 NOT IN (SELECT t2.f1
FROM (t1 AS t2 JOIN t1 AS t3 ON (t3.f1 = t2.f1))
WHERE (t3.f1 <> t2.f1 OR t3.f1 < t2.f1));
f1
DROP TABLE t1;
#
# Bug#34527126: Some rapid tests in MTR fail with hypergraph
#               when run in --ps-protocol mode
#
CREATE TABLE t1(f1 INTEGER);
PREPARE ps FROM
"SELECT * FROM (WITH RECURSIVE qn AS (SELECT 1 FROM t1 UNION ALL
                                      SELECT 1 FROM t1 STRAIGHT_JOIN qn)
                                     SELECT * FROM qn) AS dt1,
                                     (SELECT COUNT(*) FROM t1) AS dt2";
EXECUTE ps;
ERROR HY000: In recursive query block of Recursive Common Table Expression 'qn', the recursive table must neither be in the right argument of a LEFT JOIN, nor be forced to be non-first with join order hints
DROP TABLE t1;
#
# Bug#34494877: WL#14449: Offload issue: RapidException (3):
#               rpdrqctr_transcode.c:1447 @ rpdoqc_
#
CREATE TABLE t(x INT, y INT);
INSERT INTO t VALUES (1, 10), (2, 20), (3, 30);
ANALYZE TABLE t;
Table	Op	Msg_type	Msg_text
test.t	analyze	status	OK
EXPLAIN FORMAT=TREE SELECT * FROM
t RIGHT JOIN
(SELECT MAX(y) AS m FROM t WHERE FALSE GROUP BY x) AS dt
ON t.x = dt.m;
EXPLAIN
-> Zero rows (Impossible WHERE)  (cost=0..0 rows=0)

SELECT * FROM
t RIGHT JOIN
(SELECT MAX(y) AS m FROM t WHERE FALSE GROUP BY x) AS dt
ON t.x = dt.m;
x	y	m
EXPLAIN FORMAT=TREE SELECT * FROM
t LEFT JOIN
(SELECT MAX(y) AS m FROM t WHERE FALSE GROUP BY x) AS dt
ON t.x = dt.m;
EXPLAIN
-> Nested loop left join  (rows=3)
    -> Table scan on t  (rows=3)
    -> Zero rows (Impossible WHERE)  (rows=0)

SELECT * FROM
t LEFT JOIN
(SELECT MAX(y) AS m FROM t WHERE FALSE GROUP BY x) AS dt
ON t.x = dt.m;
x	y	m
1	10	NULL
2	20	NULL
3	30	NULL
EXPLAIN FORMAT=TREE SELECT * FROM
t AS t1 LEFT JOIN
(t AS t2
INNER JOIN (SELECT MAX(y) AS m FROM t WHERE FALSE GROUP BY x) AS dt
ON t2.x = dt.m)
ON t1.x = t2.y;
EXPLAIN
-> Nested loop left join  (rows=3)
    -> Table scan on t1  (rows=3)
    -> Zero rows (impossible WHERE)  (rows=0)

SELECT * FROM
t AS t1 LEFT JOIN
(t AS t2
INNER JOIN (SELECT MAX(y) AS m FROM t WHERE FALSE GROUP BY x) AS dt
ON t2.x = dt.m)
ON t1.x = t2.y;
x	y	x	y	m
1	10	NULL	NULL	NULL
2	20	NULL	NULL	NULL
3	30	NULL	NULL	NULL
DROP TABLE t;
#
# Bug#34534373: Heatwave offload issue - Sees inner tables of
#               a semijoin when it should not
#
CREATE TABLE t1 (f1 INTEGER);
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
EXPLAIN FORMAT=tree
SELECT 1
FROM t1 LEFT JOIN (SELECT * FROM t1 AS t2
WHERE f1 IN (SELECT f1+1 FROM t1 AS t3)) AS dt
ON t1.f1=dt.f1;
EXPLAIN
-> Left hash join (t1.f1 = t2.f1)  (rows=1)
    -> Table scan on t1  (rows=1)
    -> Hash
        -> Hash semijoin (FirstMatch) (t2.f1 = (t3.f1 + 1))  (rows=0.1)
            -> Table scan on t2  (rows=1)
            -> Hash
                -> Table scan on t3  (rows=1)

DROP TABLE t1;
#
# Bug#34699398: Row estimates for joins ignores histograms.
#
CREATE TABLE num (n INT);
INSERT INTO num VALUES (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);
CREATE TABLE t1 (a INT, ah INT, ai INT, KEY ix1(ai));
INSERT INTO t1 SELECT k%25, k%25, K%25 FROM
(SELECT num1.n+num2.n*10 k FROM num num1, num num2) d1;
CREATE TABLE t2 (b INT, bh INT, bi INT, KEY ix2(bi));
INSERT INTO t2 SELECT k%25, k%25, k%25 FROM
(SELECT num1.n+num2.n*10 k FROM num num1, num num2, num num3) d1;
ANALYZE TABLE t1 UPDATE HISTOGRAM ON ah;
Table	Op	Msg_type	Msg_text
test.t1	histogram	status	Histogram statistics created for column 'ah'.
ANALYZE TABLE t2 UPDATE HISTOGRAM ON bh;
Table	Op	Msg_type	Msg_text
test.t2	histogram	status	Histogram statistics created for column 'bh'.
ANALYZE TABLE t1,t2;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
EXPLAIN ANALYZE SELECT 1 FROM t1,t2 WHERE a=b;
EXPLAIN
-> Inner hash join (t1.a = t2.b)  (rows=10000) (actual rows=4000 loops=1)
    -> Table scan on t2  (rows=1000) (actual rows=1000 loops=1)
    -> Hash
        -> Table scan on t1  (rows=100) (actual rows=100 loops=1)

EXPLAIN ANALYZE SELECT 1 FROM t1 x1, t1 x2 WHERE x1.a=x2.a;
EXPLAIN
-> Inner hash join (x1.a = x2.a)  (rows=1000) (actual rows=400 loops=1)
    -> Table scan on x1  (rows=100) (actual rows=100 loops=1)
    -> Hash
        -> Table scan on x2  (rows=100) (actual rows=100 loops=1)

EXPLAIN ANALYZE SELECT 1 FROM t2 x1, t2 x2 WHERE x1.b=x2.b;
EXPLAIN
-> Inner hash join (x1.b = x2.b)  (rows=100000) (actual rows=40000 loops=1)
    -> Table scan on x1  (rows=1000) (actual rows=1000 loops=1)
    -> Hash
        -> Table scan on x2  (rows=1000) (actual rows=1000 loops=1)

EXPLAIN ANALYZE SELECT 1 FROM t1,t2 WHERE ai=b;
EXPLAIN
-> Inner hash join (t1.ai = t2.b)  (rows=4000) (actual rows=4000 loops=1)
    -> Table scan on t2  (rows=1000) (actual rows=1000 loops=1)
    -> Hash
        -> Table scan on t1  (rows=100) (actual rows=100 loops=1)

EXPLAIN ANALYZE SELECT 1 FROM t1 x1, t1 x2 WHERE x1.ai=x2.ai;
EXPLAIN
-> Inner hash join (x1.ai = x2.ai)  (rows=400) (actual rows=400 loops=1)
    -> Table scan on x1  (rows=100) (actual rows=100 loops=1)
    -> Hash
        -> Table scan on x2  (rows=100) (actual rows=100 loops=1)

EXPLAIN ANALYZE SELECT 1 FROM t1,t2 WHERE ai=bi;
EXPLAIN
-> Inner hash join (t1.ai = t2.bi)  (rows=4000) (actual rows=4000 loops=1)
    -> Covering index scan on t2 using ix2  (rows=1000) (actual rows=1000 loops=1)
    -> Hash
        -> Table scan on t1  (rows=100) (actual rows=100 loops=1)

EXPLAIN ANALYZE SELECT 1 FROM t1,t2 WHERE a=bi;
EXPLAIN
-> Inner hash join (t1.a = t2.bi)  (rows=4000) (actual rows=4000 loops=1)
    -> Covering index scan on t2 using ix2  (rows=1000) (actual rows=1000 loops=1)
    -> Hash
        -> Table scan on t1  (rows=100) (actual rows=100 loops=1)

EXPLAIN ANALYZE SELECT 1 FROM t2 x1, t2 x2 WHERE x1.bi=x2.bi;
EXPLAIN
-> Inner hash join (x1.bi = x2.bi)  (rows=40000) (actual rows=40000 loops=1)
    -> Covering index scan on x1 using ix2  (rows=1000) (actual rows=1000 loops=1)
    -> Hash
        -> Covering index scan on x2 using ix2  (rows=1000) (actual rows=1000 loops=1)

EXPLAIN ANALYZE SELECT 1 FROM t1,t2 WHERE ah=b;
EXPLAIN
-> Inner hash join (t1.ah = t2.b)  (rows=4000) (actual rows=4000 loops=1)
    -> Table scan on t2  (rows=1000) (actual rows=1000 loops=1)
    -> Hash
        -> Table scan on t1  (rows=100) (actual rows=100 loops=1)

EXPLAIN ANALYZE SELECT 1 FROM t1 x1, t1 x2 WHERE x1.ah=x2.ah;
EXPLAIN
-> Inner hash join (x1.ah = x2.ah)  (rows=400) (actual rows=400 loops=1)
    -> Table scan on x1  (rows=100) (actual rows=100 loops=1)
    -> Hash
        -> Table scan on x2  (rows=100) (actual rows=100 loops=1)

EXPLAIN ANALYZE SELECT 1 FROM t1,t2 WHERE ah=bh;
EXPLAIN
-> Inner hash join (t1.ah = t2.bh)  (rows=4000) (actual rows=4000 loops=1)
    -> Table scan on t2  (rows=1000) (actual rows=1000 loops=1)
    -> Hash
        -> Table scan on t1  (rows=100) (actual rows=100 loops=1)

EXPLAIN ANALYZE SELECT 1 FROM t1,t2 WHERE a=bh;
EXPLAIN
-> Inner hash join (t1.a = t2.bh)  (rows=4000) (actual rows=4000 loops=1)
    -> Table scan on t2  (rows=1000) (actual rows=1000 loops=1)
    -> Hash
        -> Table scan on t1  (rows=100) (actual rows=100 loops=1)

EXPLAIN ANALYZE SELECT 1 FROM t2 x1, t2 x2 WHERE x1.bh=x2.bh;
EXPLAIN
-> Inner hash join (x1.bh = x2.bh)  (rows=40000) (actual rows=40000 loops=1)
    -> Table scan on x1  (rows=1000) (actual rows=1000 loops=1)
    -> Hash
        -> Table scan on x2  (rows=1000) (actual rows=1000 loops=1)

DROP TABLE num, t1, t2;
#
# Bug#34682561: Assertion `!eq_items.is_empty()' failed
#               in make_join_hypergraph.cc
#
CREATE TABLE t1 (f1 INTEGER, f2 INTEGER);
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
EXPLAIN FORMAT=tree SELECT f1 FROM t1
WHERE EXISTS (SELECT t2.f1
FROM (t1 AS t2 JOIN t1 AS t3 ON (t3.f1 = t2.f2))
LEFT JOIN t1 AS t4 ON TRUE
WHERE t4.f1 = t3.f1 OR t3.f2 >= t2.f2)
GROUP BY f1;
EXPLAIN
-> Group (no aggregates)  (rows=0.1)
    -> Sort: t1.f1  (rows=0.1)
        -> Nested loop inner join (FirstMatch)  (rows=0.1)
            -> Limit: 1 row(s)  (rows=0.1)
                -> Filter: (((t3.f1 = t2.f2) and (t2.f2 = t4.f1)) or (t3.f2 >= t3.f1))  (rows=0.1)
                    -> Left hash join (no condition)  (rows=0.1)
                        -> Inner hash join (t3.f1 = t2.f2)  (rows=0.1)
                            -> Table scan on t2  (rows=1)
                            -> Hash
                                -> Table scan on t3  (rows=1)
                        -> Hash
                            -> Table scan on t4  (rows=1)
            -> Table scan on t1  (rows=1)

SELECT f1 FROM t1
WHERE EXISTS (SELECT t2.f1
FROM (t1 AS t2 JOIN t1 AS t3 ON (t3.f1 = t2.f2))
LEFT JOIN t1 AS t4 ON TRUE
WHERE t4.f1 = t3.f1 OR t3.f2 >= t2.f2)
GROUP BY f1;
f1
DROP TABLE t1;
#
# Bug#34717171: Hypergraph :Assertion `false' failed
#               in join_optimizer.cc
#
CREATE TABLE t1 (pk INT PRIMARY KEY AUTO_INCREMENT, x INT);
CREATE TABLE t2 (x INT);
INSERT INTO t1 VALUES (), (), (), (), (), (), (), (), (), ();
INSERT INTO t2 VALUES (), (), (), (), (), (), (), (), (), ();
ANALYZE TABLE t1,t2;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
EXPLAIN FORMAT=tree WITH subq AS (
SELECT * FROM t2
WHERE x IN (SELECT t1.pk FROM t1, t2 AS t3 WHERE t1.x = t3.x)
)
SELECT 1 FROM subq LEFT JOIN t2 AS t4 ON TRUE WHERE subq.x = t4.x;
EXPLAIN
-> Inner hash join (t2.x = t4.x)  (rows=3.16)
    -> Table scan on t4  (rows=10)
    -> Hash
        -> Hash semijoin (FirstMatch) (t2.x = t1.pk)  (rows=3.16)
            -> Table scan on t2  (rows=10)
            -> Hash
                -> Inner hash join (t1.x = t3.x)  (rows=10)
                    -> Table scan on t1  (rows=10)
                    -> Hash
                        -> Table scan on t3  (rows=10)

WITH subq AS (
SELECT * FROM t2
WHERE x IN (SELECT t1.pk FROM t1, t2 AS t3 WHERE t1.x = t3.x)
)
SELECT 1 FROM subq LEFT JOIN t2 AS t4 ON TRUE WHERE subq.x = t4.x;
1
DROP TABLE t1,t2;
#
# Bug#34828364: Assertion `!eq_items.is_empty()' failed
#               in make_join_hypergraph.cc
#
CREATE TABLE t1 (f1 INTEGER, f2 INTEGER);
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
EXPLAIN FORMAT=tree SELECT 1
FROM (SELECT * FROM t1
WHERE f1 IN (SELECT t1.f1 FROM (t1 AS t2 JOIN t1 AS t3 ON t3.f1 = t2.f2)
LEFT JOIN t1 AS t4 ON TRUE
WHERE (t3.f2 <> t3.f2 OR t4.f2 = t2.f2))) AS t5 JOIN t1 AS t6
ON TRUE;
EXPLAIN
-> Inner hash join (no condition)  (rows=10e-6)
    -> Table scan on t6  (rows=1)
    -> Hash
        -> Hash semijoin (FirstMatch) (no condition)  (rows=10e-6)
            -> Filter: (t1.f1 = t1.f1)  (rows=0.1)
                -> Table scan on t1  (rows=1)
            -> Hash
                -> Filter: (t2.f2 = t4.f2)  (rows=100e-6)
                    -> Left hash join (no condition)  (rows=0.001)
                        -> Filter: (t3.f1 = t2.f2)  (rows=0.001)
                            -> Inner hash join (t2.f2 = t3.f1), (t3.f1 = t2.f2)  (rows=0.01)
                                -> Table scan on t2  (rows=1)
                                -> Hash
                                    -> Table scan on t3  (rows=1)
                        -> Hash
                            -> Table scan on t4  (rows=1)

Warnings:
Note	1276	Field or reference 'test.t1.f1' of SELECT #3 was resolved in SELECT #2
SELECT 1
FROM (SELECT * FROM t1
WHERE f1 IN (SELECT t1.f1 FROM (t1 AS t2 JOIN t1 AS t3 ON t3.f1 = t2.f2)
LEFT JOIN t1 AS t4 ON TRUE
WHERE (t3.f2 <> t3.f2 OR t4.f2 = t2.f2))) AS t5 JOIN t1 AS t6
ON TRUE;
1
DROP TABLE t1;
#
# Bug#34821222: Hypergraph: mysqld crash-signal 11 - IsAnd &
#               CommonSubexpressionElimination
#
CREATE TABLE t1 (x INTEGER NOT NULL);
CREATE TABLE t2 (y INTEGER, z INTEGER);
SELECT 1 IN (
SELECT COUNT(*) FROM t1 WHERE x NOT IN (
SELECT 1 FROM t2 WHERE y <> y OR z <> z));
1 IN (
SELECT COUNT(*) FROM t1 WHERE x NOT IN (
SELECT 1 FROM t2 WHERE y <> y OR z <> z))
0
DROP TABLE t1, t2;
#
# Bug#34854369: Customer query hits assert(m_pq.is_valid()) failure
#
CREATE TABLE t (table_id BIGINT UNSIGNED);
SELECT /*+ SET_VAR(optimizer_max_subgraph_pairs = 1) */ 1
FROM t AS t1 JOIN t AS t2 USING (table_id)
JOIN INFORMATION_SCHEMA.INNODB_TABLES AS t3 USING (table_id)
JOIN INFORMATION_SCHEMA.INNODB_TABLES AS t4 USING (table_id)
JOIN INFORMATION_SCHEMA.INNODB_TABLES AS t5 USING (table_id)
JOIN INFORMATION_SCHEMA.INNODB_TABLES AS t6 USING (table_id)
JOIN INFORMATION_SCHEMA.INNODB_TABLES AS t7 USING (table_id)
JOIN INFORMATION_SCHEMA.INNODB_TABLES AS t8 USING (table_id);
1
DROP TABLE t;
CREATE TABLE t0 (x INT) ENGINE = MyISAM;
CREATE TABLE t1 (x INT) ENGINE = InnoDB;
SELECT /*+ SET_VAR(optimizer_max_subgraph_pairs = 1) */ 1
FROM t0 AS a NATURAL JOIN
t0 AS b NATURAL JOIN
t0 AS c NATURAL JOIN
t0 AS d NATURAL JOIN
t0 AS e NATURAL JOIN
t0 AS f NATURAL JOIN
t1 AS g NATURAL JOIN
t1 AS h;
1
DROP TABLE t0, t1;
#
# Bug#34861693: Assertion
# `std::abs(1.0 - EstimateAggregateRows(child, query_block, path->aggreg
#
CREATE TABLE num (n INT);
INSERT INTO num VALUES (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);
CREATE TABLE t1 (a INT, b INT);
INSERT INTO t1 SELECT n,n FROM num UNION SELECT n+10,n+10 FROM num;
CREATE TABLE t2 (a INT, b INT);
ANALYZE TABLE t1, t2;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
EXPLAIN FORMAT=TREE SELECT x1.a+0 k, COUNT(x1.b) FROM t1 x1
LEFT JOIN t2 x2 ON x1.b=x2.a
LEFT JOIN t1 x3 ON x2.b=x3.a GROUP BY k;
EXPLAIN
-> Group aggregate: count(x1.b)  (rows=4.47)
    -> Sort: k  (rows=20)
        -> Left hash join (x1.b = x2.a)  (rows=20)
            -> Table scan on x1  (rows=20)
            -> Hash
                -> Left hash join (x2.b = x3.a)  (rows=2)
                    -> Table scan on x2  (rows=1)
                    -> Hash
                        -> Table scan on x3  (rows=20)

DROP TABLE t1,t2,num;
#
# Bug#35000554: assertion error in EstimateAggregateNoRollupRows()
#
CREATE TABLE num10 (n INT);
INSERT INTO num10 VALUES (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);
CREATE TABLE t1(a INT, b INT, c INT);
ANALYZE TABLE t1 UPDATE HISTOGRAM ON a, b, c;
Table	Op	Msg_type	Msg_text
test.t1	histogram	status	Histogram statistics created for column 'a'.
test.t1	histogram	status	Histogram statistics created for column 'b'.
test.t1	histogram	status	Histogram statistics created for column 'c'.
INSERT INTO t1 SELECT NULL, x1.n+x2.n*10, NULL FROM num10 x1, num10 x2;
INSERT INTO t1 VALUES (NULL, 0, 0);
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
EXPLAIN ANALYZE SELECT b FROM t1 GROUP BY b;
EXPLAIN
-> Table scan on <temporary>  (rows=10) (actual rows=100 loops=1)
    -> Temporary table with deduplication  (rows=10) (actual rows=100 loops=1)
        -> Table scan on t1  (rows=101) (actual rows=101 loops=1)

EXPLAIN ANALYZE SELECT b FROM t1 WHERE b=c;
EXPLAIN
-> Filter: (t1.b = t1.c)  (rows=101) (actual rows=1 loops=1)
    -> Table scan on t1  (rows=101) (actual rows=101 loops=1)

ANALYZE TABLE t1 UPDATE HISTOGRAM ON a, b, c;
Table	Op	Msg_type	Msg_text
test.t1	histogram	status	Histogram statistics created for column 'a'.
test.t1	histogram	status	Histogram statistics created for column 'b'.
test.t1	histogram	status	Histogram statistics created for column 'c'.
EXPLAIN FORMAT=TREE SELECT a,b FROM t1 GROUP BY a,b;
EXPLAIN
-> Table scan on <temporary>  (rows=63.7)
    -> Temporary table with deduplication  (rows=63.7)
        -> Table scan on t1  (rows=101)

EXPLAIN ANALYZE SELECT b FROM t1 WHERE b=c;
EXPLAIN
-> Filter: (t1.b = t1.c)  (rows=1.01) (actual rows=1 loops=1)
    -> Table scan on t1  (rows=101) (actual rows=101 loops=1)

EXPLAIN ANALYZE SELECT c FROM t1 GROUP BY c;
EXPLAIN
-> Table scan on <temporary>  (rows=2) (actual rows=2 loops=1)
    -> Temporary table with deduplication  (rows=2) (actual rows=2 loops=1)
        -> Table scan on t1  (rows=101) (actual rows=101 loops=1)

DROP TABLE num10, t1;
CREATE TABLE t2(a INT, b INT);
INSERT INTO t2 VALUES (0, 0), (0, 1), (1, 2), (NULL, 3), (NULL, 4), (NULL, 5);
ANALYZE TABLE t2 UPDATE HISTOGRAM ON a, b;
Table	Op	Msg_type	Msg_text
test.t2	histogram	status	Histogram statistics created for column 'a'.
test.t2	histogram	status	Histogram statistics created for column 'b'.
ANALYZE TABLE t2;
Table	Op	Msg_type	Msg_text
test.t2	analyze	status	OK
EXPLAIN ANALYZE SELECT 1 FROM t2 WHERE a=b;
EXPLAIN
-> Filter: (t2.a = t2.b)  (rows=1.5) (actual rows=1 loops=1)
    -> Table scan on t2  (rows=6) (actual rows=6 loops=1)

DROP TABLE t2;
#
# Bug#35129863 Hypergraph: Multi-field indexes ignored in some
# selectivity estimates
#
CREATE TABLE num10 (n INT PRIMARY KEY);
INSERT INTO num10 VALUES (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);
ANALYZE TABLE num10;
Table	Op	Msg_type	Msg_text
test.num10	analyze	status	OK
CREATE TABLE t1(
a INT,
b INT,
c INT,
d INT,
e INT,
f INT,
g INT,
h INT,
v VARCHAR(5),
PRIMARY KEY(a,b,c),
KEY k1 (e,f,g),
UNIQUE KEY k2(h)
);
INSERT INTO t1
SELECT k%25, k%50, k, k, k%25, k%50, k, k, CAST( k%25 AS CHAR(5))
FROM (select x1.n*10+x2.n k from num10 x1, num10 x2) d1;
ANALYZE TABLE t1 UPDATE HISTOGRAM ON a, b,c,d,e,f,g,v;
Table	Op	Msg_type	Msg_text
test.t1	histogram	status	Histogram statistics created for column 'a'.
test.t1	histogram	status	Histogram statistics created for column 'b'.
test.t1	histogram	status	Histogram statistics created for column 'c'.
test.t1	histogram	status	Histogram statistics created for column 'd'.
test.t1	histogram	status	Histogram statistics created for column 'e'.
test.t1	histogram	status	Histogram statistics created for column 'f'.
test.t1	histogram	status	Histogram statistics created for column 'g'.
test.t1	histogram	status	Histogram statistics created for column 'v'.
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
EXPLAIN ANALYZE SELECT * FROM t1 x1, t1 x2 WHERE x1.a=x2.a AND x1.b=x2.b;
EXPLAIN
-> Inner hash join (x1.a = x2.a), (x1.b = x2.b)  (rows=200) (actual rows=200 loops=1)
    -> Table scan on x1  (rows=100) (actual rows=100 loops=1)
    -> Hash
        -> Table scan on x2  (rows=100) (actual rows=100 loops=1)

EXPLAIN ANALYZE SELECT * FROM t1 x1, t1 x2, t1 x3
WHERE x1.a=x2.a AND x1.b=x2.b AND x2.c=x3.c AND x2.d=x3.d;
EXPLAIN
-> Nested loop inner join  (rows=2) (actual rows=200 loops=1)
    -> Inner hash join (x2.c = x3.c), (x2.d = x3.d)  (rows=1) (actual rows=100 loops=1)
        -> Table scan on x3  (rows=100) (actual rows=100 loops=1)
        -> Hash
            -> Table scan on x2  (rows=100) (actual rows=100 loops=1)
    -> Index lookup on x1 using PRIMARY (a = x2.a, b = x2.b)  (rows=2) (actual rows=2 loops=100)

EXPLAIN ANALYZE SELECT * FROM t1 x1, t1 x2 WHERE x1.e=x2.e AND x1.f=x2.f;
EXPLAIN
-> Inner hash join (x1.e = x2.e), (x1.f = x2.f)  (rows=200) (actual rows=200 loops=1)
    -> Table scan on x1  (rows=100) (actual rows=100 loops=1)
    -> Hash
        -> Table scan on x2  (rows=100) (actual rows=100 loops=1)

EXPLAIN ANALYZE SELECT * FROM t1 x1, t1 x2 WHERE x1.e=x2.e AND x1.f=x2.f AND x1.g=x2.g;
EXPLAIN
-> Inner hash join (x1.e = x2.e), (x1.f = x2.f), (x1.g = x2.g)  (rows=100) (actual rows=100 loops=1)
    -> Table scan on x1  (rows=100) (actual rows=100 loops=1)
    -> Hash
        -> Table scan on x2  (rows=100) (actual rows=100 loops=1)

EXPLAIN ANALYZE SELECT * FROM t1 x1, t1 x2 WHERE x1.a=x2.a AND x1.e=x2.e;
EXPLAIN
-> Inner hash join (x1.a = x2.a), (x1.e = x2.e)  (rows=16) (actual rows=400 loops=1)
    -> Table scan on x1  (rows=100) (actual rows=100 loops=1)
    -> Hash
        -> Table scan on x2  (rows=100) (actual rows=100 loops=1)

EXPLAIN ANALYZE SELECT * FROM t1 x1, t1 x2 WHERE x1.a=x2.a AND x1.b=x2.b
AND x1.e=x2.e AND x1.f=x2.f;
EXPLAIN
-> Inner hash join (x1.a = x2.a), (x1.b = x2.b), (x1.e = x2.e), (x1.f = x2.f)  (rows=4) (actual rows=200 loops=1)
    -> Table scan on x1  (rows=100) (actual rows=100 loops=1)
    -> Hash
        -> Table scan on x2  (rows=100) (actual rows=100 loops=1)

EXPLAIN ANALYZE SELECT * FROM t1 x1, t1 x2, t1 x3 WHERE x1.a=x2.a AND x2.b=x3.b;
EXPLAIN
-> Inner hash join (x1.a = x2.a)  (rows=800) (actual rows=800 loops=1)
    -> Inner hash join (x2.b = x3.b)  (rows=200) (actual rows=200 loops=1)
        -> Table scan on x3  (rows=100) (actual rows=100 loops=1)
        -> Hash
            -> Table scan on x2  (rows=100) (actual rows=100 loops=1)
    -> Hash
        -> Table scan on x1  (rows=100) (actual rows=100 loops=1)

EXPLAIN ANALYZE SELECT * FROM t1 x1, t1 x2 WHERE x1.a=x2.a AND x1.b=8;
EXPLAIN
-> Nested loop inner join  (rows=8) (actual rows=8 loops=1)
    -> Filter: (x1.b = 8)  (rows=2) (actual rows=2 loops=1)
        -> Table scan on x1  (rows=100) (actual rows=100 loops=1)
    -> Index lookup on x2 using PRIMARY (a = x1.a)  (rows=4) (actual rows=4 loops=2)

EXPLAIN ANALYZE SELECT * FROM t1 x1, t1 x2 WHERE x1.a=x2.a AND x1.b=x2.b
AND x1.c=8;
EXPLAIN
-> Nested loop inner join  (rows=2) (actual rows=2 loops=1)
    -> Filter: (x1.c = 8)  (rows=1) (actual rows=1 loops=1)
        -> Table scan on x1  (rows=100) (actual rows=100 loops=1)
    -> Index lookup on x2 using PRIMARY (a = x1.a, b = x1.b)  (rows=2) (actual rows=2 loops=1)

EXPLAIN ANALYZE SELECT * FROM t1 x1, t1 x2 WHERE x1.a=x2.a AND x1.b=7
AND x1.c=8;
EXPLAIN
-> Nested loop inner join  (rows=0.08) (actual rows=0 loops=1)
    -> Filter: ((x1.c = 8) and (x1.b = 7))  (rows=0.02) (actual rows=0 loops=1)
        -> Table scan on x1  (rows=100) (actual rows=100 loops=1)
    -> Index lookup on x2 using PRIMARY (a = x1.a)  (rows=4) (never executed)

EXPLAIN ANALYZE SELECT * FROM t1 x1, t1 x2 WHERE x1.a=x2.a AND x1.b=x2.b
AND x1.c=x2.c;
EXPLAIN
-> Nested loop inner join  (rows=100) (actual rows=100 loops=1)
    -> Table scan on x1  (rows=100) (actual rows=100 loops=1)
    -> Single-row index lookup on x2 using PRIMARY (a = x1.a, b = x1.b, c = x1.c)  (rows=1) (actual rows=1 loops=100)

EXPLAIN ANALYZE SELECT * FROM t1 WHERE a=b;
EXPLAIN
-> Filter: (t1.a = t1.b)  (rows=4) (actual rows=50 loops=1)
    -> Table scan on t1  (rows=100) (actual rows=100 loops=1)

EXPLAIN ANALYZE SELECT * FROM t1 WHERE a=b AND c=d;
EXPLAIN
-> Filter: ((t1.c = t1.d) and (t1.a = t1.b))  (rows=0.04) (actual rows=50 loops=1)
    -> Table scan on t1  (rows=100) (actual rows=100 loops=1)

EXPLAIN ANALYZE FORMAT=TREE SELECT * FROM t1 x1, t1 x2, t1 x3
WHERE x1.a=x2.a AND x2.b=x3.b AND x3.c=x1.c;
EXPLAIN
-> Nested loop inner join  (rows=8) (actual rows=200 loops=1)
    -> Inner hash join (x3.c = x1.c)  (rows=100) (actual rows=100 loops=1)
        -> Table scan on x3  (rows=100) (actual rows=100 loops=1)
        -> Hash
            -> Table scan on x1  (rows=100) (actual rows=100 loops=1)
    -> Index lookup on x2 using PRIMARY (a = x1.a, b = x3.b)  (rows=0.08) (actual rows=2 loops=100)

EXPLAIN ANALYZE SELECT * FROM t1 JOIN num10 ON h=n;
EXPLAIN
-> Nested loop inner join  (rows=10) (actual rows=10 loops=1)
    -> Table scan on num10  (rows=10) (actual rows=10 loops=1)
    -> Single-row index lookup on t1 using k2 (h = num10.n)  (rows=1) (actual rows=1 loops=10)

EXPLAIN ANALYZE SELECT * FROM t1 x1, t1 x2, t1 x3 WHERE
x1.a=x2.a AND x1.b=x2.b AND x1.b=x3.h;
EXPLAIN
-> Nested loop inner join  (rows=4) (actual rows=200 loops=1)
    -> Nested loop inner join  (rows=4) (actual rows=200 loops=1)
        -> Table scan on x1  (rows=100) (actual rows=100 loops=1)
        -> Index lookup on x2 using PRIMARY (a = x1.a, b = x1.b)  (rows=0.04) (actual rows=2 loops=100)
    -> Single-row index lookup on x3 using k2 (h = x1.b)  (rows=1) (actual rows=1 loops=200)

EXPLAIN ANALYZE SELECT * FROM t1 x1, t1 x2, t1 x3
WHERE x1.a=x2.c AND x1.b=x2.b AND x2.b=x3.b;
EXPLAIN
-> Inner hash join (x1.b = x3.b)  (rows=10000) (actual rows=100 loops=1)
    -> Inner hash join (x1.a = x2.c), (x1.b = x2.b)  (rows=200) (actual rows=50 loops=1)
        -> Table scan on x1  (rows=100) (actual rows=100 loops=1)
        -> Hash
            -> Table scan on x2  (rows=100) (actual rows=100 loops=1)
    -> Hash
        -> Table scan on x3  (rows=100) (actual rows=100 loops=1)

EXPLAIN ANALYZE SELECT * FROM t1 x1 LEFT JOIN
(t1 x2 JOIN t1 x3 ON x2.a=x3.a AND x2.b=x3.b) ON x3.b=x1.d;
EXPLAIN
-> Left hash join (x1.d = x2.b)  (rows=400) (actual rows=250 loops=1)
    -> Table scan on x1  (rows=100) (actual rows=100 loops=1)
    -> Hash
        -> Inner hash join (x2.b = x3.b), (x2.a = x3.a)  (rows=200) (actual rows=200 loops=1)
            -> Table scan on x2  (rows=100) (actual rows=100 loops=1)
            -> Hash
                -> Table scan on x3  (rows=100) (actual rows=100 loops=1)

EXPLAIN ANALYZE SELECT 1 FROM  t1 x1
WHERE 3 IN (SELECT x2.b FROM t1 x2 LEFT JOIN t1 x3 ON x2.c=x3.a AND x2.d=x3.b);
EXPLAIN
-> Nested loop inner join (FirstMatch)  (rows=100) (actual rows=100 loops=1)
    -> Limit: 1 row(s)  (rows=1) (actual rows=1 loops=1)
        -> Nested loop left join  (rows=4) (actual rows=1 loops=1)
            -> Filter: (x2.b = 3)  (rows=2) (actual rows=1 loops=1)
                -> Table scan on x2  (rows=100) (actual rows=13 loops=1)
            -> Covering index lookup on x3 using PRIMARY (a = x2.c, b = x2.d)  (rows=2) (actual rows=1 loops=1)
    -> Covering index scan on x1 using k2  (rows=100) (actual rows=100 loops=1)

EXPLAIN ANALYZE SELECT 1 FROM t1 x1 JOIN t1 x2 ON x1.a=x2.v AND x1.b=x2.b;
EXPLAIN
-> Inner hash join (cast(x1.a as double) = cast(x2.v as double)), (x1.b = x2.b)  (rows=200) (actual rows=200 loops=1)
    -> Covering index scan on x1 using k2  (rows=100) (actual rows=100 loops=1)
    -> Hash
        -> Table scan on x2  (rows=100) (actual rows=100 loops=1)

EXPLAIN ANALYZE SELECT 1 FROM t1 x1, t1 x2, t1 x3
WHERE x1.a=x2.c AND x1.a=x3.v AND x1.b=x3.f;
EXPLAIN
-> Inner hash join (x1.a = x2.c)  (rows=800) (actual rows=200 loops=1)
    -> Inner hash join (cast(x1.a as double) = cast(x3.v as double)), (x1.b = x3.f)  (rows=200) (actual rows=200 loops=1)
        -> Covering index scan on x1 using k2  (rows=100) (actual rows=100 loops=1)
        -> Hash
            -> Table scan on x3  (rows=100) (actual rows=100 loops=1)
    -> Hash
        -> Covering index scan on x2 using k2  (rows=100) (actual rows=100 loops=1)

CREATE TABLE t2(x INT, y INT, z INT, KEY (x, y), KEY(y, x));
INSERT INTO t2(x, y) VALUES (1, 1), (2, 2), (3, 3), (4, 4);
CREATE TABLE t3 AS SELECT * FROM t2;
ANALYZE TABLE t2, t3;
Table	Op	Msg_type	Msg_text
test.t2	analyze	status	OK
test.t3	analyze	status	OK
EXPLAIN ANALYZE SELECT 1 FROM t2 JOIN t3 USING (x, y);
EXPLAIN
-> Nested loop inner join  (rows=4) (actual rows=4 loops=1)
    -> Table scan on t3  (rows=4) (actual rows=4 loops=1)
    -> Covering index lookup on t2 using x (x = t3.x, y = t3.y)  (rows=1) (actual rows=1 loops=4)

DROP TABLE t1, t2, t3, num10;
#
# Bug#34762651 Too high row estimates for DISTINCT
#
CREATE TABLE t1(
a INT PRIMARY KEY,
b INT,
KEY(b),
c INT
);
INSERT INTO t1
WITH RECURSIVE qn(n) AS (SELECT 1 UNION ALL SELECT n+1 FROM qn WHERE n<100)
SELECT n,  n%5, n%7 FROM qn;
ANALYZE TABLE t1 UPDATE HISTOGRAM ON c;
Table	Op	Msg_type	Msg_text
test.t1	histogram	status	Histogram statistics created for column 'c'.
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
EXPLAIN ANALYZE SELECT DISTINCT b FROM t1;
EXPLAIN
-> Covering index skip scan for deduplication on t1 using b  (rows=5) (actual rows=5 loops=1)

EXPLAIN ANALYZE SELECT DISTINCT c FROM t1;
EXPLAIN
-> Table scan on <temporary>  (rows=7) (actual rows=7 loops=1)
    -> Temporary table with deduplication  (rows=7) (actual rows=7 loops=1)
        -> Table scan on t1  (rows=100) (actual rows=100 loops=1)

EXPLAIN ANALYZE SELECT DISTINCT b,c FROM t1;
EXPLAIN
-> Table scan on <temporary>  (rows=20.6) (actual rows=35 loops=1)
    -> Temporary table with deduplication  (rows=20.6) (actual rows=35 loops=1)
        -> Table scan on t1  (rows=100) (actual rows=100 loops=1)

DROP TABLE t1;
#
# Bug#34763224 Hypergraph orders and-terms inefficiently in subquery
#
CREATE TABLE num (n INT);
INSERT INTO num VALUES (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);
CREATE TABLE t1(
a INT PRIMARY KEY,
b VARCHAR(128),
c INT
);
INSERT INTO t1 SELECT k, CAST(100+k AS CHAR(10)), k
FROM (SELECT x1.n+x2.n*10 AS k FROM num x1, num x2) d1;
ANALYZE TABLE t1 UPDATE HISTOGRAM ON b, c;
Table	Op	Msg_type	Msg_text
test.t1	histogram	status	Histogram statistics created for column 'b'.
test.t1	histogram	status	Histogram statistics created for column 'c'.
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
EXPLAIN FORMAT=TREE SELECT 1 FROM t1 x1 WHERE x1.c IN
(SELECT c FROM t1 x2 WHERE  b<"150" AND c<70);
EXPLAIN
-> Hash semijoin (FirstMatch) (x1.c = x2.c)  (rows=35)
    -> Table scan on x1  (rows=100)
    -> Hash
        -> Filter: ((x2.c < 70) and (x2.b < '150'))  (rows=35)
            -> Table scan on x2  (rows=100)

EXPLAIN  FORMAT=TREE SELECT 1 FROM t1 WHERE b<"150" AND c<70;
EXPLAIN
-> Filter: ((t1.c < 70) and (t1.b < '150'))  (rows=35)
    -> Table scan on t1  (rows=100)

EXPLAIN  FORMAT=TREE SELECT 1 FROM t1 WHERE b<"150" AND c<80;
EXPLAIN
-> Filter: ((t1.b < '150') and (t1.c < 80))  (rows=40)
    -> Table scan on t1  (rows=100)

#
# BUG 35507456
# Assertion `[&]() { for (const Predicate *first = begin; first < end; first++)
#
EXPLAIN FORMAT=TREE SELECT 1 FROM t1
WHERE  b<"150" AND RAND(0)>-1 AND c< 70;
EXPLAIN
-> Filter: ((t1.c < 70) and (t1.b < '150') and (rand(0) > <cache>(-(1))))  (rows=35)
    -> Table scan on t1  (rows=100)

CREATE FUNCTION foo(i INT)
RETURNS INT
LANGUAGE SQL
BEGIN
RETURN i+1;
END $$
EXPLAIN FORMAT=TREE SELECT 1 FROM t1 WHERE foo(2)=3 AND c=5;
EXPLAIN
-> Filter: ((t1.c = 5) and (foo(2) = 3))  (rows=1)
    -> Table scan on t1  (rows=100)

DROP FUNCTION foo;
DROP TABLE num, t1;
#
# Bug#36316088 	Mysqld crash - Assertion `false &&
# "Inconsistent row counts for differ
#
CREATE TABLE t1(
a INT,
b INT
);
INSERT INTO t1 values (1,1),(2,2);
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
CREATE FUNCTION func(x INT) RETURNS INTEGER NO SQL RETURN x+1;
EXPLAIN FORMAT=TREE SELECT * FROM t1 x1, t1 x2
WHERE func(x1.b)=x2.b AND x1.a=x2.a;
EXPLAIN
-> Filter: (func(x1.b) = x2.b)  (rows=0.4)
    -> Inner hash join (x1.a = x2.a)  (rows=0.4)
        -> Table scan on x1  (rows=2)
        -> Hash
            -> Table scan on x2  (rows=2)

DROP FUNCTION func;
DROP TABLE t1;
#
# Bug#34787357 Hypergraph: row estimates for field=non_field_term
# ignores indexes and histogram
#
CREATE TABLE t1 (
a INT,
b INT,
c INT,
d INT,
e INT,
f INT,
g INT,
PRIMARY KEY(a),
KEY k1 (b,d), --  'b' and 'd' are indepdendent.
KEY k2 (b,e), -- 'b' is funtionally dependent on 'e'.
KEY k3 (b,g), -- 'b' is funtionally dependent on 'g'.
KEY k4 (f,g) -- 'f' and 'g' are independet.
);
INSERT INTO t1
WITH RECURSIVE qn(n) AS
(SELECT 0 UNION ALL SELECT n+1 FROM qn WHERE n<255)
SELECT n AS a, n DIV 16 AS b, n % 16 AS c, n % 16 AS d, n DIV 8 AS e,
n % 32 AS f, n DIV 8 AS g FROM qn;
ANALYZE TABLE t1 UPDATE HISTOGRAM ON c;
Table	Op	Msg_type	Msg_text
test.t1	histogram	status	Histogram statistics created for column 'c'.
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
EXPLAIN ANALYZE SELECT 1 FROM t1 WHERE b=FLOOR(RAND(0));
EXPLAIN
-> Filter: (t1.b = floor(rand(0)))  (rows=16) (actual rows=16 loops=1)
    -> Covering index scan on t1 using k1  (rows=256) (actual rows=256 loops=1)

EXPLAIN ANALYZE SELECT 1 FROM t1 WHERE c=FLOOR(RAND(0));
EXPLAIN
-> Filter: (t1.c = floor(rand(0)))  (rows=16) (actual rows=16 loops=1)
    -> Table scan on t1  (rows=256) (actual rows=256 loops=1)

EXPLAIN ANALYZE SELECT 1 FROM t1 WHERE FLOOR(RAND(0))=c;
EXPLAIN
-> Filter: (floor(rand(0)) = t1.c)  (rows=16) (actual rows=16 loops=1)
    -> Table scan on t1  (rows=256) (actual rows=256 loops=1)

EXPLAIN ANALYZE SELECT 1 FROM t1 WHERE d=FLOOR(RAND(0));
EXPLAIN
-> Filter: (t1.d = floor(rand(0)))  (rows=4) (actual rows=16 loops=1)
    -> Covering index scan on t1 using k1  (rows=256) (actual rows=256 loops=1)

EXPLAIN ANALYZE SELECT 1 FROM t1 WHERE e=FLOOR(RAND(0));
EXPLAIN
-> Filter: (t1.e = floor(rand(0)))  (rows=32) (actual rows=8 loops=1)
    -> Covering index scan on t1 using k2  (rows=256) (actual rows=256 loops=1)

EXPLAIN ANALYZE SELECT 1 FROM t1 WHERE d=0;
EXPLAIN
-> Covering index skip scan on t1 using k1 over d = 0  (rows=4) (actual rows=16 loops=1)

EXPLAIN ANALYZE SELECT 1 FROM t1 WHERE e=0;
EXPLAIN
-> Covering index skip scan on t1 using k2 over e = 0  (rows=32) (actual rows=8 loops=1)

EXPLAIN ANALYZE SELECT 1 FROM t1 WHERE g=FLOOR(RAND(0));
EXPLAIN
-> Filter: (t1.g = floor(rand(0)))  (rows=13.5) (actual rows=8 loops=1)
    -> Covering index scan on t1 using k3  (rows=256) (actual rows=256 loops=1)

EXPLAIN ANALYZE SELECT 1 FROM t1 WHERE b=(SELECT MIN(b) FROM t1);
EXPLAIN
-> Filter: (t1.b = (select #2))  (rows=16) (actual rows=16 loops=1)
    -> Covering index lookup on t1 using k1 (b = (select #2))  (rows=16) (actual rows=16 loops=1)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: min(t1.b)  (rows=1) (actual rows=1 loops=1)
            -> Covering index scan on t1 using k1  (rows=256) (actual rows=256 loops=1)

EXPLAIN ANALYZE SELECT 1 FROM t1 WHERE c=(SELECT MIN(b) FROM t1);
EXPLAIN
-> Filter: (t1.c = (select #2))  (rows=16) (actual rows=16 loops=1)
    -> Table scan on t1  (rows=256) (actual rows=256 loops=1)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: min(t1.b)  (rows=1) (actual rows=1 loops=1)
            -> Covering index scan on t1 using k1  (rows=256) (actual rows=256 loops=1)

EXPLAIN ANALYZE SELECT 1 FROM t1 WHERE b<>FLOOR(RAND(0));
EXPLAIN
-> Filter: (t1.b <> floor(rand(0)))  (rows=240) (actual rows=240 loops=1)
    -> Covering index scan on t1 using k1  (rows=256) (actual rows=256 loops=1)

EXPLAIN ANALYZE SELECT 1 FROM t1 WHERE c<>FLOOR(RAND(0));
EXPLAIN
-> Filter: (t1.c <> floor(rand(0)))  (rows=240) (actual rows=240 loops=1)
    -> Table scan on t1  (rows=256) (actual rows=256 loops=1)

EXPLAIN ANALYZE SELECT 1 FROM t1 WHERE FLOOR(RAND(0))<>c;
EXPLAIN
-> Filter: (floor(rand(0)) <> t1.c)  (rows=240) (actual rows=240 loops=1)
    -> Table scan on t1  (rows=256) (actual rows=256 loops=1)

EXPLAIN ANALYZE SELECT 1 FROM t1 WHERE b<>(SELECT MIN(b) FROM t1);
EXPLAIN
-> Filter: (t1.b <> (select #2))  (rows=240) (actual rows=240 loops=1)
    -> Covering index scan on t1 using k1  (rows=256) (actual rows=256 loops=1)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: min(t1.b)  (rows=1) (actual rows=1 loops=1)
            -> Covering index scan on t1 using k1  (rows=256) (actual rows=256 loops=1)

EXPLAIN ANALYZE SELECT 1 FROM t1 WHERE c<>(SELECT MIN(b) FROM t1);
EXPLAIN
-> Filter: (t1.c <> (select #2))  (rows=240) (actual rows=240 loops=1)
    -> Table scan on t1  (rows=256) (actual rows=256 loops=1)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: min(t1.b)  (rows=1) (actual rows=1 loops=1)
            -> Covering index scan on t1 using k1  (rows=256) (actual rows=256 loops=1)

EXPLAIN ANALYZE SELECT 1 FROM t1 WHERE d<>(SELECT MIN(b) FROM t1);
EXPLAIN
-> Filter: (t1.d <> (select #2))  (rows=252) (actual rows=240 loops=1)
    -> Covering index scan on t1 using k1  (rows=256) (actual rows=256 loops=1)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: min(t1.b)  (rows=1) (actual rows=1 loops=1)
            -> Covering index scan on t1 using k1  (rows=256) (actual rows=256 loops=1)

EXPLAIN ANALYZE SELECT 1 FROM t1 WHERE e<>(SELECT MIN(b) FROM t1);
EXPLAIN
-> Filter: (t1.e <> (select #2))  (rows=224) (actual rows=248 loops=1)
    -> Covering index scan on t1 using k2  (rows=256) (actual rows=256 loops=1)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: min(t1.b)  (rows=1) (actual rows=1 loops=1)
            -> Covering index scan on t1 using k1  (rows=256) (actual rows=256 loops=1)

EXPLAIN ANALYZE FORMAT=TREE SELECT * FROM t1 x1 WHERE d =
(SELECT MIN(g) FROM t1 x2 WHERE x1.b<>x2.b);
EXPLAIN
-> Filter: (x1.d = (select #2))  (rows=256) (actual rows=16 loops=1)
    -> Table scan on x1  (rows=256) (actual rows=256 loops=1)
    -> Select #2 (subquery in condition; dependent)
        -> Aggregate: min(x2.g)  (rows=1) (actual rows=1 loops=256)
            -> Filter: (x1.b <> x2.b)  (rows=240) (actual rows=240 loops=256)
                -> Covering index scan on x2 using k3  (rows=256) (actual rows=256 loops=256)

Warnings:
Note	1276	Field or reference 'test.x1.b' of SELECT #2 was resolved in SELECT #1
DROP TABLE t1;
# Bug#35439787 Assertion `false && "Inconsistent row counts for
# different AccessPath objects."'
#
CREATE TABLE t1 (
a INT PRIMARY KEY,
b INT,
c INT,
d INT,
e INT,
KEY k1 (b,c)
);
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
EXPLAIN FORMAT=TREE SELECT 1 FROM t1 x1 WHERE EXISTS
(SELECT 1 FROM t1 x2, t1 x3, t1 x4
WHERE x2.b=x3.d AND x2.c=x3.e AND x3.d=x4.b AND x2.e=x4.e);
EXPLAIN
-> Nested loop inner join (FirstMatch)  (rows=0.1)
    -> Limit: 1 row(s)  (rows=0.1)
        -> Inner hash join (x2.b = x3.d), (x2.c = x3.e)  (rows=0.1)
            -> Table scan on x3  (rows=1)
            -> Hash
                -> Inner hash join (x2.e = x4.e), (x2.b = x4.b)  (rows=0.1)
                    -> Table scan on x2  (rows=1)
                    -> Hash
                        -> Table scan on x4  (rows=1)
    -> Table scan on x1  (rows=1)

DROP TABLE t1;
CREATE TABLE t1 (a int, b int);
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
EXPLAIN FORMAT=TREE SELECT * FROM  t1 x1 LEFT JOIN (t1 x2, t1 x3)
ON x1.a=x3.a WHERE x1.b<x2.b OR x2.a IS NULL;
EXPLAIN
-> Filter: ((x1.b < x2.b) or (x2.a is null))  (rows=1)
    -> Left hash join (x1.a = x3.a)  (rows=1)
        -> Table scan on x1  (rows=1)
        -> Hash
            -> Inner hash join (no condition)  (rows=1)
                -> Table scan on x2  (rows=1)
                -> Hash
                    -> Table scan on x3  (rows=1)

DROP TABLE t1;
#
# Bug#35719688 Assertion`new_path->cost >= new_path->init_cost' in
# ExpandSingleFilterAccessPath
#
CREATE TABLE t1 (
a INT,
b INT,
c INT,
PRIMARY KEY(a),
KEY k_b(b),
KEY k_c(c)
);
INSERT INTO t1 VALUES (1,1,1);
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
CREATE TABLE t2 (
a INT PRIMARY KEY,
b INT
);
INSERT INTO t2 WITH RECURSIVE qn(n) AS
(SELECT 1 UNION ALL SELECT n+1 FROM qn WHERE n<50) SELECT n, n FROM qn;
ANALYZE TABLE t2;
Table	Op	Msg_type	Msg_text
test.t2	analyze	status	OK
EXPLAIN FORMAT=TREE SELECT * FROM t1 x0 WHERE (b=3 OR c=4) AND a <>
(SELECT MAX(x1.a+x2.a) FROM t2 x1 JOIN t2 x2 ON x1.b<x2.b);
EXPLAIN
-> Filter: (((x0.b = 3) or (x0.c = 4)) and (x0.a <> (select #2)))  (rows=0.2)
    -> Table scan on x0  (rows=1)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: max((x1.a + x2.a))  (rows=1)
            -> Inner hash join (no condition), extra conditions: (x1.b < x2.b)  (rows=833)
                -> Table scan on x1  (rows=50)
                -> Hash
                    -> Table scan on x2  (rows=50)

DROP TABLE t1,t2;
#
# Bug#35789967 Assertion `val >= 0.0 || val == kUnknownCost' failed.
#
CREATE TABLE t1
(
a INT,
b INT,
c INT,
PRIMARY KEY(a),
KEY k2 (b,c)
);
INSERT INTO t1
WITH RECURSIVE qn(n) AS (SELECT 10 UNION ALL SELECT n-1 FROM qn WHERE n>0)
SELECT n, 1, n FROM qn;
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
EXPLAIN FORMAT=TREE SELECT b FROM t1 x1
WHERE c < 1 AND c = (SELECT MAX(b) FROM t1 x2);
EXPLAIN
-> Filter: (x1.c = (select #2))  (...)
    -> Covering index skip scan on x1 using k2 over NULL < c < 1  (...)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: max(x2.b)  (...)
            -> Table scan on x2  (...)

DROP TABLE t1;
#
# Bug#35790381 Assertion `false &&
# "Inconsistent row counts for different AccessPath objects."'
#
CREATE TABLE t1 (a INT, b INT, KEY k1 (a));
INSERT INTO t1 VALUES (1,1),(2,2),(1,1),(2,2),(1,1),(2,2),(1,1),(2,2),(1,1),(2,2),(1,1),(2,2);
ANALYZE TABLE t1 UPDATE HISTOGRAM ON b;
Table	Op	Msg_type	Msg_text
test.t1	histogram	status	Histogram statistics created for column 'b'.
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
EXPLAIN FORMAT=TREE SELECT a, COUNT(*) FROM
(SELECT x1.a FROM t1 x1, t1 x2 WHERE x1.b = x2.a) AS dt GROUP BY a;
EXPLAIN
-> Group aggregate: count(0)  (rows=2)
    -> Nested loop inner join  (rows=72)
        -> Sort: a  (rows=12)
            -> Table scan on x1  (rows=12)
        -> Covering index lookup on x2 using k1 (a = x1.b)  (rows=6)

DROP TABLE t1;
#
# Bug#35483044 Hypergraph: Invalid row estimate for filter on
# 'Index range scan'
#
CREATE TABLE t1 (
a INT PRIMARY KEY,
b INT NOT NULL,
c INT,
KEY k_b(b),
KEY k_c(c)
);
INSERT INTO t1 WITH RECURSIVE qn(n) AS
(SELECT 1 UNION ALL SELECT n+1 FROM qn WHERE n<30) SELECT n, n/2, n/2 FROM qn;
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
EXPLAIN FORMAT=TREE SELECT * FROM t1 WHERE b=5 OR c=NULL;
EXPLAIN
-> Filter: ((t1.b = 5) or (t1.c = NULL))  (rows=2)
    -> Index range scan on t1 using k_b over (b = 5)  (rows=2)

EXPLAIN FORMAT=TREE SELECT * FROM t1 WHERE b=5 OR c<=>NULL;
EXPLAIN
-> Deduplicate rows sorted by row ID  (rows=4.8)
    -> Index range scan on t1 using k_b over (b = 5)  (rows=2)
    -> Index range scan on t1 using k_c over (c = NULL)  (rows=1)

EXPLAIN FORMAT=TREE SELECT * FROM t1 WHERE b=5 OR c IS NULL;
EXPLAIN
-> Deduplicate rows sorted by row ID  (rows=4.8)
    -> Index range scan on t1 using k_b over (b = 5)  (rows=2)
    -> Index range scan on t1 using k_c over (c = NULL)  (rows=1)

EXPLAIN FORMAT=TREE SELECT * FROM t1 WHERE b=NULL OR c=5;
EXPLAIN
-> Filter: ((t1.b = NULL) or (t1.c = 5))  (rows=2)
    -> Index range scan on t1 using k_c over (c = 5)  (rows=2)

EXPLAIN FORMAT=TREE SELECT * FROM t1 WHERE b<=>NULL OR c=5;
EXPLAIN
-> Filter: ((t1.b <=> NULL) or (t1.c = 5))  (rows=2)
    -> Index range scan on t1 using k_c over (c = 5)  (rows=2)

EXPLAIN FORMAT=TREE SELECT * FROM t1 WHERE b<=>FLOOR(RAND(0));
EXPLAIN
-> Filter: (t1.b <=> floor(rand(0)))  (rows=2)
    -> Table scan on t1  (rows=30)

EXPLAIN FORMAT=TREE SELECT * FROM t1 WHERE c<=>FLOOR(RAND(0));
EXPLAIN
-> Filter: (t1.c <=> floor(rand(0)))  (rows=2)
    -> Table scan on t1  (rows=30)

ANALYZE TABLE t1 UPDATE HISTOGRAM ON b,c;
Table	Op	Msg_type	Msg_text
test.t1	histogram	status	Histogram statistics created for column 'b'.
test.t1	histogram	status	Histogram statistics created for column 'c'.
EXPLAIN FORMAT=TREE SELECT * FROM t1 WHERE b=5 OR c=NULL;
EXPLAIN
-> Filter: ((t1.b = 5) or (t1.c = NULL))  (rows=2)
    -> Index range scan on t1 using k_b over (b = 5)  (rows=2)

EXPLAIN FORMAT=TREE SELECT * FROM t1 WHERE b=5 OR c<=>NULL;
EXPLAIN
-> Deduplicate rows sorted by row ID  (rows=2.03)
    -> Index range scan on t1 using k_b over (b = 5)  (rows=2)
    -> Index range scan on t1 using k_c over (c = NULL)  (rows=1)

EXPLAIN FORMAT=TREE SELECT * FROM t1 WHERE b=5 OR c IS NULL;
EXPLAIN
-> Deduplicate rows sorted by row ID  (rows=2.03)
    -> Index range scan on t1 using k_b over (b = 5)  (rows=2)
    -> Index range scan on t1 using k_c over (c = NULL)  (rows=1)

EXPLAIN FORMAT=TREE SELECT * FROM t1 WHERE b=NULL OR c=5;
EXPLAIN
-> Filter: ((t1.b = NULL) or (t1.c = 5))  (rows=2)
    -> Index range scan on t1 using k_c over (c = 5)  (rows=2)

EXPLAIN FORMAT=TREE SELECT * FROM t1 WHERE b<=>NULL OR c=5;
EXPLAIN
-> Filter: ((t1.b <=> NULL) or (t1.c = 5))  (rows=2)
    -> Index range scan on t1 using k_c over (c = 5)  (rows=2)

EXPLAIN FORMAT=TREE SELECT * FROM t1 WHERE b<=>FLOOR(RAND(0));
EXPLAIN
-> Filter: (t1.b <=> floor(rand(0)))  (rows=2)
    -> Table scan on t1  (rows=30)

EXPLAIN FORMAT=TREE SELECT * FROM t1 WHERE c<=>FLOOR(RAND(0));
EXPLAIN
-> Filter: (t1.c <=> floor(rand(0)))  (rows=2)
    -> Table scan on t1  (rows=30)

DROP TABLE t1;
#
# Bug#35898221 Hypergraph: too low row estmate for semijoin
# that is not an equijoin
#
CREATE TABLE t1 (
a INT PRIMARY KEY,
b INT
);
CREATE TABLE t2 (
k INT,
l INT,
PRIMARY KEY(k)
);
INSERT INTO t1 WITH RECURSIVE qn(n) AS
(SELECT 0 UNION ALL SELECT n+1 FROM qn WHERE n<29) SELECT n, n FROM qn;
INSERT INTO t2 WITH RECURSIVE qn(n) AS
(SELECT 0 UNION ALL SELECT n+1 FROM qn WHERE n<19) SELECT n, n%10 FROM qn;
ANALYZE TABLE t1 UPDATE HISTOGRAM ON b;
Table	Op	Msg_type	Msg_text
test.t1	histogram	status	Histogram statistics created for column 'b'.
ANALYZE TABLE t2 UPDATE HISTOGRAM ON l;
Table	Op	Msg_type	Msg_text
test.t2	histogram	status	Histogram statistics created for column 'l'.
ANALYZE TABLE t1,t2;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
EXPLAIN ANALYZE SELECT * FROM t1 WHERE t1.a IN (SELECT t2.l FROM t2);
EXPLAIN
-> Nested loop inner join (LooseScan)  (rows=10) (actual rows=10 loops=1)
    -> Remove duplicates from input grouped on t2.l  (rows=10) (actual rows=10 loops=1)
        -> Sort: t2.l  (rows=20) (actual rows=20 loops=1)
            -> Table scan on t2  (rows=20) (actual rows=20 loops=1)
    -> Single-row index lookup on t1 using PRIMARY (a = t2.l)  (rows=1) (actual rows=1 loops=10)

EXPLAIN ANALYZE SELECT * FROM t1 WHERE EXISTS
(SELECT 1 FROM t2 WHERE t1.a=t2.l AND t1.b<>t2.k);
EXPLAIN
-> Hash semijoin (FirstMatch) (t1.a = t2.l), extra conditions: (t1.b <> t2.k)  (rows=14.3) (actual rows=10 loops=1)
    -> Table scan on t1  (rows=30) (actual rows=30 loops=1)
    -> Hash
        -> Table scan on t2  (rows=20) (actual rows=20 loops=1)

Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #2 was resolved in SELECT #1
Note	1276	Field or reference 'test.t1.b' of SELECT #2 was resolved in SELECT #1
EXPLAIN ANALYZE SELECT * FROM t1 WHERE EXISTS
(SELECT 1 FROM t2 WHERE t2.l+ABS(t2.l)=t1.a);
EXPLAIN
-> Nested loop inner join (LooseScan)  (rows=10) (actual rows=10 loops=1)
    -> Remove duplicates from input grouped on (t2.l + abs(t2.l))  (rows=4.47) (actual rows=10 loops=1)
        -> Sort: (t2.l + abs(t2.l))  (rows=20) (actual rows=20 loops=1)
            -> Table scan on t2  (rows=20) (actual rows=20 loops=1)
    -> Filter: (t1.a = (t2.l + abs(t2.l)))  (rows=0.0333) (actual rows=1 loops=10)
        -> Single-row index lookup on t1 using PRIMARY (a = (t2.l + abs(t2.l)))  (rows=1) (actual rows=1 loops=10)

Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #2 was resolved in SELECT #1
EXPLAIN ANALYZE SELECT * FROM t1 WHERE EXISTS
(SELECT 1 FROM t2 WHERE t2.k+t2.l=t1.a);
EXPLAIN
-> Nested loop inner join (LooseScan)  (rows=14.8) (actual rows=15 loops=1)
    -> Remove duplicates from input grouped on (t2.k + t2.l)  (rows=4.47) (actual rows=15 loops=1)
        -> Sort: (t2.k + t2.l)  (rows=20) (actual rows=20 loops=1)
            -> Table scan on t2  (rows=20) (actual rows=20 loops=1)
    -> Filter: (t1.a = (t2.k + t2.l))  (rows=0.0333) (actual rows=1 loops=15)
        -> Single-row index lookup on t1 using PRIMARY (a = (t2.k + t2.l))  (rows=1) (actual rows=1 loops=15)

Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #2 was resolved in SELECT #1
EXPLAIN ANALYZE SELECT * FROM t1 WHERE NOT EXISTS
(SELECT 1 FROM t2 WHERE t1.a=t2.l);
EXPLAIN
-> Hash antijoin (t1.a = t2.l)  (rows=20) (actual rows=20 loops=1)
    -> Table scan on t1  (rows=30) (actual rows=30 loops=1)
    -> Hash
        -> Table scan on t2  (rows=20) (actual rows=20 loops=1)

Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #2 was resolved in SELECT #1
EXPLAIN ANALYZE SELECT * FROM t1 WHERE NOT EXISTS
(SELECT 1 FROM t2 WHERE t1.a=t2.l AND t1.b<>t2.k);
EXPLAIN
-> Hash antijoin (t1.a = t2.l), extra conditions: (t1.b <> t2.k)  (rows=15.7) (actual rows=20 loops=1)
    -> Table scan on t1  (rows=30) (actual rows=30 loops=1)
    -> Hash
        -> Table scan on t2  (rows=20) (actual rows=20 loops=1)

Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #2 was resolved in SELECT #1
Note	1276	Field or reference 'test.t1.b' of SELECT #2 was resolved in SELECT #1
EXPLAIN FORMAT=TREE SELECT * FROM t1 WHERE a IN
(SELECT t2.l FROM t2 WHERE t2.l<0);
EXPLAIN
-> Nested loop inner join (LooseScan)  (rows=0.02)
    -> Remove duplicates from input grouped on t2.l  (rows=0.02)
        -> Sort: t2.l  (rows=0.02)
            -> Filter: (t2.l < 0)  (rows=0.02)
                -> Table scan on t2  (rows=20)
    -> Single-row index lookup on t1 using PRIMARY (a = t2.l)  (rows=1)

EXPLAIN FORMAT=TREE SELECT * FROM t1 WHERE t1.a IN (SELECT 5 FROM t2);
EXPLAIN
-> Nested loop inner join (FirstMatch)  (rows=1)
    -> Limit: 1 row(s)  (rows=1)
        -> Table scan on t2  (rows=20)
    -> Single-row index lookup on t1 using PRIMARY (a = 5)  (rows=1)

DROP TABLE t1,t2;
#
# Bug#35997316 Hypergraph: Incomplete and inconvenient optimizer trace
#
CREATE TABLE t1 (a INT PRIMARY KEY, b INT);
INSERT INTO t1 WITH RECURSIVE qn(n) AS
(SELECT 0 UNION ALL SELECT n+1 FROM qn WHERE n+1<30) SELECT n, n%10 FROM qn;
ANALYZE TABLE t1 UPDATE HISTOGRAM ON b;
Table	Op	Msg_type	Msg_text
test.t1	histogram	status	Histogram statistics created for column 'b'.
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
SET SESSION OPTIMIZER_TRACE='enabled=on';
EXPLAIN FORMAT=TREE SELECT * FROM t1 x1
WHERE x1.a IN (SELECT x2.b FROM t1 x2);
EXPLAIN
-> Nested loop inner join (LooseScan)  (rows=10)
    -> Remove duplicates from input grouped on x2.b  (rows=10)
        -> Sort: x2.b  (rows=30)
            -> Table scan on x2  (rows=30)
    -> Single-row index lookup on x1 using PRIMARY (a = x2.b)  (rows=1)

SELECT REGEXP_SUBSTR(
trace, "distinct values for field 'b' from histogram[^,]*",1,1,'n')
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;
REGEXP_SUBSTR(
trace, "distinct values for field 'b' from histogram[^,]*",1,1,'n')
distinct values for field 'b' from histogram."
SET SESSION OPTIMIZER_TRACE='enabled=off';
DROP TABLE t1;
#
# Bug#36125903 Hypergraph: Inconsistent numeric precision for
# AccessPath in optimizer trace
#
CREATE TABLE t1 (
a INT PRIMARY KEY,
b INT
);
INSERT INTO t1 WITH RECURSIVE qn(n) AS
(SELECT 0 UNION ALL SELECT n+1 FROM qn WHERE n<100) SELECT n, n FROM qn;
ANALYZE TABLE t1 UPDATE HISTOGRAM ON b;
Table	Op	Msg_type	Msg_text
test.t1	histogram	status	Histogram statistics created for column 'b'.
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
SET SESSION OPTIMIZER_TRACE="enabled=on";
EXPLAIN FORMAT=TREE SELECT * FROM t1 x1, t1 x2, t1 x3, t1 x4;
EXPLAIN
-> Inner hash join (no condition)  (rows=104e+6)
    -> Inner hash join (no condition)  (rows=1.03e+6)
        -> Inner hash join (no condition)  (rows=10201)
            -> Table scan on x1  (rows=101)
            -> Hash
                -> Table scan on x2  (rows=101)
        -> Hash
            -> Table scan on x3  (rows=101)
    -> Hash
        -> Table scan on x4  (rows=101)

SELECT REGEXP_SUBSTR(trace, " - \\{HASH_JOIN[^\n]*keeping",1,1,'n')
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;
REGEXP_SUBSTR(trace, " - \\{HASH_JOIN[^\n]*keeping",1,1,'n')
 - {HASH_JOIN, cost=1655, init_cost=188, rescan_cost=1468, rows=10201, join_order=(x1,x2)} is first alternative, keeping
EXPLAIN FORMAT=TREE SELECT * FROM t1 WHERE a=5 AND b=5;
EXPLAIN
-> Filter: (t1.b = 5)  (rows=0.0099)
    -> Single-row index lookup on t1 using PRIMARY (a = 5)  (rows=1)

SELECT REGEXP_SUBSTR(trace, " - \\{FILTER[^\n]*keeping",1,1,'n')
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;
REGEXP_SUBSTR(trace, " - \\{FILTER[^\n]*keeping",1,1,'n')
 - {FILTER, cost=2.04, init_cost=0, rows=0.0099} is first alternative, keeping
SET SESSION OPTIMIZER_TRACE="enabled=off";
DROP TABLE t1;
#
# Bug#33502694 Hypergraph optimizer trace does not respect memory limits
#
CREATE TABLE t1(
pk INT PRIMARY KEY,
a INT,
KEY ka(a),
b INT,
KEY kb(b)
);
INSERT INTO t1
WITH RECURSIVE qn(n) AS (SELECT 1 UNION ALL SELECT n+1 FROM qn WHERE n<100)
SELECT n, n%11, n%11 FROM qn;
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
SET @old_optimizer_trace_max_mem_size=@@optimizer_trace_max_mem_size;
SET SESSION optimizer_trace_max_mem_size=16384;
SET SESSION OPTIMIZER_TRACE='enabled=on';
EXPLAIN FORMAT=JSON INTO @explain_output
SELECT a FROM t1 x2 WHERE x2.b IN
(SELECT a FROM t1 x1 WHERE x1.b IN (SELECT a FROM t1 x0));
SELECT
CAST(LENGTH(TRACE) AS DOUBLE) / @@optimizer_trace_max_mem_size
BETWEEN 0.9 AND 1.1 AS trace_length_ok,
MISSING_BYTES_BEYOND_MAX_MEM_SIZE BETWEEN 10000 AND 30000 AS excess_length_ok
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;
trace_length_ok	excess_length_ok
1	1
SET SESSION optimizer_trace_max_mem_size=@old_optimizer_trace_max_mem_size;
SET SESSION OPTIMIZER_TRACE='enabled=off';
DROP TABLE t1;
# Bug#5889990: Setting secondary_engine to OFF causes offload issues
CREATE TABLE t(x INT, y INT);
INSERT INTO t VALUES (1, 2), (2, 3);
ANALYZE TABLE t;
Table	Op	Msg_type	Msg_text
test.t	analyze	status	OK
SET optimizer_switch='hypergraph_optimizer=off';
PREPARE ps FROM
'SELECT *
 FROM t AS t1 LEFT JOIN t AS t2 ON t1.x=t2.x AND t1.y IN (SELECT x FROM t)';
EXECUTE ps;
x	y	x	y
1	2	1	2
2	3	NULL	NULL
SET optimizer_switch='hypergraph_optimizer=on';
EXECUTE ps;
x	y	x	y
1	2	1	2
2	3	NULL	NULL
SET optimizer_switch='hypergraph_optimizer=off';
EXECUTE ps;
x	y	x	y
1	2	1	2
2	3	NULL	NULL
SET optimizer_switch='hypergraph_optimizer=on';
PREPARE ps FROM
'SELECT *
 FROM t AS t1 LEFT JOIN t AS t2 ON t1.x=t2.x AND t1.y IN (SELECT x FROM t)';
EXECUTE ps;
x	y	x	y
1	2	1	2
2	3	NULL	NULL
SET optimizer_switch='hypergraph_optimizer=off';
EXECUTE ps;
x	y	x	y
1	2	1	2
2	3	NULL	NULL
DROP TABLE t;
CREATE TABLE t(x VARCHAR(100), FULLTEXT KEY (x));
INSERT INTO t VALUES ('abc'), ('xyz'), ('abc abc');
ANALYZE TABLE t;
Table	Op	Msg_type	Msg_text
test.t	analyze	status	OK
SET optimizer_switch='hypergraph_optimizer=on';
PREPARE ps FROM
'SELECT x, MATCH(x) AGAINST (''abc'') AS score FROM t
 GROUP BY x HAVING MATCH(x) AGAINST(''abc'') > 0';
EXECUTE ps;
x	score
abc	0.031008131802082062
abc abc	0.062016263604164124
SET optimizer_switch='hypergraph_optimizer=off';
EXECUTE ps;
x	score
abc	0.031008131802082062
abc abc	0.062016263604164124
SET optimizer_switch='hypergraph_optimizer=on';
EXECUTE ps;
x	score
abc	0.031008131802082062
abc abc	0.062016263604164124
SET optimizer_switch='hypergraph_optimizer=off';
PREPARE ps FROM
'SELECT x, MATCH(x) AGAINST (''abc'') AS score FROM t
 GROUP BY x HAVING MATCH(x) AGAINST(''abc'') > 0';
EXECUTE ps;
x	score
abc	0.031008131802082062
abc abc	0.062016263604164124
SET optimizer_switch='hypergraph_optimizer=on';
EXECUTE ps;
x	score
abc	0.031008131802082062
abc abc	0.062016263604164124
DROP TABLE t;
#
# Bug #36135001: Hypergraph: Too low row estimate for index lookup
#
CREATE TABLE t1(
a INT,
b INT,
c INT,
d INT,
PRIMARY KEY(a),
KEY k1(d)
);
INSERT INTO t1
WITH RECURSIVE qn(n) AS
(SELECT 0 UNION ALL SELECT n+1 FROM qn WHERE n<19)
SELECT n, n%10, n%10, n%10 FROM qn;
ANALYZE TABLE t1 UPDATE HISTOGRAM ON b,c;
Table	Op	Msg_type	Msg_text
test.t1	histogram	status	Histogram statistics created for column 'b'.
test.t1	histogram	status	Histogram statistics created for column 'c'.
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
EXPLAIN FORMAT=TREE SELECT * FROM t1 x1, t1 x2, t1 x3
WHERE x1.b=x2.a AND x2.b=x3.a AND (x1.c < 5 OR x3.c=7);
EXPLAIN
-> Nested loop inner join  (rows=20)
    -> Nested loop inner join  (rows=20)
        -> Table scan on x1  (rows=20)
        -> Single-row index lookup on x2 using PRIMARY (a = x1.b)  (rows=1)
    -> Filter: ((x1.c < 5) or (x3.c = 7))  (rows=1)
        -> Single-row index lookup on x3 using PRIMARY (a = x2.b)  (rows=1)

EXPLAIN FORMAT=TREE SELECT * FROM t1 x1, t1 x2, t1 x3
WHERE x1.b=x2.d AND x2.b=x3.d AND (x1.c < 5 OR x3.c=7) ORDER BY x3.d;
EXPLAIN
-> Sort: x3.d  (rows=80)
    -> Inner hash join (x1.b = x2.d), extra conditions: ((x1.c < 5) or (x3.c = 7))  (rows=80)
        -> Inner hash join (x2.b = x3.d)  (rows=40)
            -> Table scan on x3  (rows=20)
            -> Hash
                -> Table scan on x2  (rows=20)
        -> Hash
            -> Table scan on x1  (rows=20)

EXPLAIN FORMAT=TREE SELECT * FROM t1 x1 LEFT JOIN t1 x2
ON x1.a <=> x2.a AND  x1.a <=> x2.a;
EXPLAIN
-> Left hash join (x1.a <=> x2.a), (x1.a <=> x2.a)  (rows=20)
    -> Table scan on x1  (rows=20)
    -> Hash
        -> Table scan on x2  (rows=20)

DROP TABLE t1;
#
# Bug#35855573 Assertion `false && "Inconsistent row counts for
# different AccessPath objects."'
#
CREATE TABLE t(pk INT PRIMARY KEY AUTO_INCREMENT, x INT);
INSERT INTO t VALUES (), (), (), (), (), (), (), (), (), (), (), ();
ANALYZE TABLE t;
Table	Op	Msg_type	Msg_text
test.t	analyze	status	OK
EXPLAIN FORMAT=TREE SELECT SQL_BIG_RESULT DISTINCT t1.x, t2.x FROM t AS t1, t AS t2
WHERE t1.pk = t2.x ORDER BY t2.x;
EXPLAIN
-> Sort with duplicate removal: t2.x  (rows=7.96)
    -> Nested loop inner join  (rows=12)
        -> Table scan on t2  (rows=12)
        -> Single-row index lookup on t1 using PRIMARY (pk = t2.x)  (rows=1)

EXPLAIN FORMAT=TREE SELECT SQL_SMALL_RESULT DISTINCT t1.x, t2.x FROM t AS t1, t AS t2
WHERE t1.pk = t2.x ORDER BY t2.x;
EXPLAIN
-> Sort: t2.x  (rows=7.96)
    -> Table scan on <temporary>  (rows=7.96)
        -> Temporary table with deduplication  (rows=7.96)
            -> Nested loop inner join  (rows=12)
                -> Table scan on t2  (rows=12)
                -> Single-row index lookup on t1 using PRIMARY (pk = t2.x)  (rows=1)

EXPLAIN FORMAT=TREE SELECT SQL_BIG_RESULT DISTINCT t1.x, t1.pk FROM t AS t1, t AS t2
WHERE t1.pk = t2.x ORDER BY t1.x;
EXPLAIN
-> Sort with duplicate removal: t1.x, t1.pk  (rows=9.36)
    -> Nested loop inner join  (rows=12)
        -> Table scan on t2  (rows=12)
        -> Single-row index lookup on t1 using PRIMARY (pk = t2.x)  (rows=1)

EXPLAIN FORMAT=TREE SELECT SQL_SMALL_RESULT DISTINCT t1.x, t1.pk FROM t AS t1, t AS t2
WHERE t1.pk = t2.x ORDER BY t1.x;
EXPLAIN
-> Sort: t1.x  (rows=9.36)
    -> Table scan on <temporary>  (rows=9.36)
        -> Temporary table with deduplication  (rows=9.36)
            -> Nested loop inner join  (rows=12)
                -> Table scan on t2  (rows=12)
                -> Single-row index lookup on t1 using PRIMARY (pk = t2.x)  (rows=1)

EXPLAIN FORMAT=TREE SELECT SQL_BIG_RESULT DISTINCT t1.pk, t2.x FROM t AS t1, t AS t2
WHERE t1.pk = t2.x ORDER BY t2.x;
EXPLAIN
-> Sort with duplicate removal: t2.x  (rows=3.46)
    -> Nested loop inner join  (rows=12)
        -> Table scan on t2  (rows=12)
        -> Single-row covering index lookup on t1 using PRIMARY (pk = t2.x)  (rows=1)

EXPLAIN FORMAT=TREE SELECT SQL_SMALL_RESULT DISTINCT t1.pk, t2.x FROM t AS t1, t AS t2
WHERE t1.pk = t2.x ORDER BY t2.x;
EXPLAIN
-> Sort: t2.x  (rows=3.46)
    -> Table scan on <temporary>  (rows=3.46)
        -> Temporary table with deduplication  (rows=3.46)
            -> Nested loop inner join  (rows=12)
                -> Table scan on t2  (rows=12)
                -> Single-row covering index lookup on t1 using PRIMARY (pk = t2.x)  (rows=1)

DROP TABLE t;
#
# Bug#35991881 Hypergraph: Wrong init_cost for nested loop join
#
CREATE TABLE t1 (
a INT PRIMARY KEY,
b INT,
c INT
);
INSERT INTO t1 WITH RECURSIVE qn(n) AS
(SELECT 0 UNION ALL SELECT n+1 FROM qn WHERE n+1<20)
SELECT n, n%10, n%10 FROM qn;
ANALYZE TABLE t1 UPDATE HISTOGRAM ON b, c;
Table	Op	Msg_type	Msg_text
test.t1	histogram	status	Histogram statistics created for column 'b'.
test.t1	histogram	status	Histogram statistics created for column 'c'.
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
EXPLAIN FORMAT=TREE SELECT * FROM t1 x1 JOIN
(SELECT MAX(x2.c) k FROM t1 x2 JOIN t1 x3 ON x2.c < x3.b GROUP BY x3.c) d1
ON x1.b=d1.k ORDER BY x1.a LIMIT 1;
EXPLAIN
-> Limit: 1 row(s)  (rows=1)
    -> Nested loop inner join  (rows=20)
        -> Index scan on x1 using PRIMARY  (rows=20)
        -> Covering index lookup on d1 using <auto_key0> (k = x1.b)  (rows=1)
            -> Materialize  (rows=10)
                -> Table scan on <temporary>  (rows=10)
                    -> Aggregate using temporary table  (rows=10)
                        -> Inner hash join (no condition), extra conditions: (x2.c < x3.b)  (rows=133)
                            -> Table scan on x2  (rows=20)
                            -> Hash
                                -> Table scan on x3  (rows=20)

DROP TABLE t1;
#
# Bug#36032958: Assertion `IsEmpty(child.delayed_predicates)' failed
#
CREATE TABLE t(x INT, KEY(x));
SELECT ROW_NUMBER() OVER () FROM t WHERE x = RAND() GROUP BY x;
ROW_NUMBER() OVER ()
DROP TABLE t;
#
# Bug#36099491: Assertion secondary_engine_cost_hook != nullptr
#               failed with hypergraph_optimizer
#
CREATE TABLE t (a INT, b VARCHAR(10));
INSERT INTO t (a)
WITH RECURSIVE 150tup(n) AS
(SELECT 1 UNION ALL SELECT n + 1 FROM 150tup WHERE n < 150)
SELECT n FROM 150tup;
ANALYZE TABLE t;
Table	Op	Msg_type	Msg_text
test.t	analyze	status	OK
SELECT /*+ SET_VAR(optimizer_max_subgraph_pairs = 1) */ COUNT(*)
FROM t AS t1 LEFT JOIN t AS t2 ON TRUE
WHERE t1.a IN (SELECT * FROM (SELECT DISTINCT t2.a) AS t3);
COUNT(*)
150
EXPLAIN FORMAT=TREE
SELECT /*+ SET_VAR(optimizer_max_subgraph_pairs = 1) */ COUNT(*)
FROM t AS t1 LEFT JOIN t AS t2 ON TRUE,
LATERAL (SELECT DISTINCT t2.a FROM t) AS t3
WHERE t1.a = t3.a;
SELECT /*+ SET_VAR(optimizer_max_subgraph_pairs = 1) */ COUNT(*)
FROM t AS t1 LEFT JOIN t AS t2 ON 1,
JSON_TABLE(t2.b, '$[*]' COLUMNS(i INT PATH '$[0]')) AS t3
WHERE t3.i < 10 AND t1.a = t3.i;
COUNT(*)
0
DROP TABLE t;
#
# Bug#36098954: Assertion GraphSimplifier::EdgesAreNeighboring
#               failed with hypergraph_optimizer
#
CREATE TABLE t(x INT);
SELECT /*+ SET_VAR(optimizer_max_subgraph_pairs = 1) */ 1
FROM t WHERE x IN (
SELECT NULL FROM t AS t1, t AS t2 STRAIGHT_JOIN t AS t3 ON t2.x = t3.x
) OR x = 1;
1
DROP TABLE t;
#
# Bug#36578613: Hypergraph result difference when querying I_S.TABLES
#
CREATE TABLE t(x INT, y LONGTEXT);
INSERT INTO t VALUES (1, 'a'), (2, 'b'), (3, 'c'), (4, 'd'), (5, 'e'), (6, 'f');
ANALYZE TABLE t;
Table	Op	Msg_type	Msg_text
test.t	analyze	status	OK
EXPLAIN FORMAT=JSON INTO @explain SELECT DISTINCT t1.x, t1.y
FROM t AS t1, t AS t2 WHERE t1.x = t2.x
ORDER BY -t1.x;
SELECT
JSON_EXTRACT(@explain, '$.access_type') AS sort_for_order_by,
JSON_EXTRACT(@explain, '$.inputs[0].access_type') AS sort_for_distinct,
JSON_EXTRACT(@explain, '$.inputs[0].inputs[0].join_algorithm') AS hash_join;
sort_for_order_by	"sort"
sort_for_distinct	"sort"
hash_join	"hash"
SELECT DISTINCT t1.x, t1.y
FROM t AS t1, t AS t2 WHERE t1.x = t2.x
ORDER BY -t1.x;
x	y
6	f
5	e
4	d
3	c
2	b
1	a
DROP TABLE t;
#
# Bug#36715239: Assertion `found_a_plan || is_secondary_engine' failed.
#
CREATE TABLE t(a INT, b INT, c INT);
INSERT INTO t VALUES (1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6);
ANALYZE TABLE t;
Table	Op	Msg_type	Msg_text
test.t	analyze	status	OK
EXPLAIN FORMAT=TREE WITH s AS (
SELECT b FROM t AS t2
WHERE EXISTS (SELECT * FROM t AS t3 WHERE t2.b = t3.c OR t3.c = 0)
)
SELECT t1.a, s.b FROM t AS t1 LEFT JOIN s ON t1.a = s.b;
EXPLAIN
-> Left hash join (t1.a = t2.b), extra conditions: ((t1.a = t2.b) or (t3.c = 0))  (rows=4)
    -> Table scan on t1  (rows=4)
    -> Hash
        -> Nested loop inner join (FirstMatch)  (rows=4)
            -> Limit: 1 row(s)  (rows=1)
                -> Table scan on t3  (rows=4)
            -> Table scan on t2  (rows=4)

Warnings:
Note	1276	Field or reference 'test.t2.b' of SELECT #3 was resolved in SELECT #2
WITH s AS (
SELECT b FROM t AS t2
WHERE EXISTS (SELECT * FROM t AS t3 WHERE t2.b = t3.c OR t3.c = 0)
)
SELECT t1.a, s.b FROM t AS t1 LEFT JOIN s ON t1.a = s.b;
a	b
1	NULL
2	2
3	3
4	4
DROP TABLE t;
