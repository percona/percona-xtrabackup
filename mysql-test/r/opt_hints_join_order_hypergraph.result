CREATE TABLE small_tab (val INT);
INSERT INTO small_tab VALUES (1), (2), (3), (4);
CREATE TABLE medium_tab (val INT);
INSERT INTO medium_tab SELECT COUNT(*) FROM small_tab;
INSERT INTO medium_tab SELECT COUNT(*) FROM medium_tab;
INSERT INTO medium_tab SELECT COUNT(*) FROM medium_tab;
CREATE TABLE large_tab (val INT);
INSERT INTO large_tab SELECT COUNT(*) FROM medium_tab;
INSERT INTO large_tab SELECT COUNT(*) FROM large_tab;
INSERT INTO large_tab SELECT COUNT(*) FROM large_tab;
SELECT COUNT(*) FROM small_tab;
COUNT(*)
4
SELECT COUNT(*) FROM medium_tab;
COUNT(*)
3
SELECT COUNT(*) FROM large_tab;
COUNT(*)
3
ANALYZE TABLE small_tab, medium_tab, large_tab;
Table	Op	Msg_type	Msg_text
test.small_tab	analyze	status	OK
test.medium_tab	analyze	status	OK
test.large_tab	analyze	status	OK
JOIN_FIXED_ORDER hint
EXPLAIN FORMAT=TREE SELECT /*+ JOIN_FIXED_ORDER() */ COUNT(*) FROM small_tab JOIN large_tab USING(val) JOIN medium_tab USING(val);
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Inner hash join (large_tab.val = medium_tab.val)  (rows=0.36)
        -> Table scan on medium_tab  (rows=3)
        -> Hash
            -> Inner hash join (small_tab.val = large_tab.val)  (rows=1.2)
                -> Table scan on large_tab  (rows=3)
                -> Hash
                    -> Table scan on small_tab  (rows=4)

EXPLAIN FORMAT=TREE SELECT /*+ JOIN_FIXED_ORDER() */ COUNT(*) FROM medium_tab JOIN small_tab USING(val) JOIN large_tab USING(val);
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Inner hash join (small_tab.val = large_tab.val)  (rows=0.36)
        -> Table scan on large_tab  (rows=3)
        -> Hash
            -> Inner hash join (medium_tab.val = small_tab.val)  (rows=1.2)
                -> Table scan on small_tab  (rows=4)
                -> Hash
                    -> Table scan on medium_tab  (rows=3)

EXPLAIN FORMAT=TREE SELECT COUNT(*) FROM large_tab WHERE val IN
(SELECT /*+ QB_NAME(subq1) JOIN_FIXED_ORDER(@subq1) */ val FROM small_tab JOIN medium_tab USING(val));
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Filter: <in_optimizer>(large_tab.val,large_tab.val in (select #2))  (rows=3)
        -> Table scan on large_tab  (rows=3)
        -> Select #2 (subquery in condition; run only once)
            -> Filter: ((large_tab.val = `<materialized_subquery>`.val))  (rows=1)
                -> Limit: 1 row(s)  (rows=1)
                    -> Index lookup on <materialized_subquery> using <auto_distinct_key> (val = large_tab.val)
                        -> Materialize with deduplication  (rows=1.2)
                            -> Inner hash join (small_tab.val = medium_tab.val)  (rows=1.2)
                                -> Table scan on medium_tab  (rows=3)
                                -> Hash
                                    -> Table scan on small_tab  (rows=4)

EXPLAIN FORMAT=TREE SELECT /*+ JOIN_FIXED_ORDER() */ COUNT(*) FROM large_tab JOIN small_tab JOIN medium_tab;
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Inner hash join (no condition)  (rows=36)
        -> Table scan on medium_tab  (rows=3)
        -> Hash
            -> Inner hash join (no condition)  (rows=12)
                -> Table scan on small_tab  (rows=4)
                -> Hash
                    -> Table scan on large_tab  (rows=3)

EXPLAIN FORMAT=TREE SELECT COUNT(*) FROM large_tab WHERE val IN
(SELECT /*+ QB_NAME(subq1) JOIN_FIXED_ORDER(@subq1) */ small_tab.val FROM medium_tab JOIN small_tab);
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Filter: <in_optimizer>(large_tab.val,large_tab.val in (select #2))  (rows=3)
        -> Table scan on large_tab  (rows=3)
        -> Select #2 (subquery in condition; run only once)
            -> Filter: ((large_tab.val = `<materialized_subquery>`.val))  (rows=1)
                -> Limit: 1 row(s)  (rows=1)
                    -> Index lookup on <materialized_subquery> using <auto_distinct_key> (val = large_tab.val)
                        -> Materialize with deduplication  (rows=12)
                            -> Inner hash join (no condition)  (rows=12)
                                -> Table scan on small_tab  (rows=4)
                                -> Hash
                                    -> Table scan on medium_tab  (rows=3)

SELECT STRAIGHT_JOIN hint
EXPLAIN FORMAT=TREE SELECT STRAIGHT_JOIN COUNT(*) FROM small_tab JOIN large_tab USING(val) JOIN medium_tab USING(val);
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Inner hash join (large_tab.val = medium_tab.val)  (rows=0.36)
        -> Table scan on medium_tab  (rows=3)
        -> Hash
            -> Inner hash join (small_tab.val = large_tab.val)  (rows=1.2)
                -> Table scan on large_tab  (rows=3)
                -> Hash
                    -> Table scan on small_tab  (rows=4)

EXPLAIN FORMAT=TREE SELECT STRAIGHT_JOIN COUNT(*) FROM medium_tab JOIN small_tab USING(val) JOIN large_tab USING(val);
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Inner hash join (small_tab.val = large_tab.val)  (rows=0.36)
        -> Table scan on large_tab  (rows=3)
        -> Hash
            -> Inner hash join (medium_tab.val = small_tab.val)  (rows=1.2)
                -> Table scan on small_tab  (rows=4)
                -> Hash
                    -> Table scan on medium_tab  (rows=3)

EXPLAIN FORMAT=TREE SELECT STRAIGHT_JOIN COUNT(*) FROM medium_tab JOIN large_tab USING(val) JOIN small_tab USING(val);
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Inner hash join (large_tab.val = small_tab.val)  (rows=0.36)
        -> Table scan on small_tab  (rows=4)
        -> Hash
            -> Inner hash join (medium_tab.val = large_tab.val)  (rows=0.9)
                -> Table scan on large_tab  (rows=3)
                -> Hash
                    -> Table scan on medium_tab  (rows=3)

EXPLAIN FORMAT=TREE SELECT STRAIGHT_JOIN COUNT(*) FROM large_tab JOIN small_tab JOIN medium_tab;
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Inner hash join (no condition)  (rows=36)
        -> Table scan on medium_tab  (rows=3)
        -> Hash
            -> Inner hash join (no condition)  (rows=12)
                -> Table scan on small_tab  (rows=4)
                -> Hash
                    -> Table scan on large_tab  (rows=3)

EXPLAIN FORMAT=TREE SELECT STRAIGHT_JOIN COUNT(*) FROM large_tab JOIN medium_tab JOIN small_tab;
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Inner hash join (no condition)  (rows=36)
        -> Table scan on small_tab  (rows=4)
        -> Hash
            -> Inner hash join (no condition)  (rows=9)
                -> Table scan on medium_tab  (rows=3)
                -> Hash
                    -> Table scan on large_tab  (rows=3)

SELECT <table1> STRAIGHT_JOIN <table2> hint
EXPLAIN FORMAT=TREE SELECT COUNT(*) FROM small_tab STRAIGHT_JOIN large_tab USING(val) STRAIGHT_JOIN medium_tab USING(val);
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Inner hash join (large_tab.val = medium_tab.val)  (rows=0.36)
        -> Table scan on medium_tab  (rows=3)
        -> Hash
            -> Inner hash join (small_tab.val = large_tab.val)  (rows=1.2)
                -> Table scan on large_tab  (rows=3)
                -> Hash
                    -> Table scan on small_tab  (rows=4)

EXPLAIN FORMAT=TREE SELECT COUNT(*) FROM medium_tab STRAIGHT_JOIN small_tab USING(val) STRAIGHT_JOIN large_tab USING(val);
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Inner hash join (small_tab.val = large_tab.val)  (rows=0.36)
        -> Table scan on large_tab  (rows=3)
        -> Hash
            -> Inner hash join (medium_tab.val = small_tab.val)  (rows=1.2)
                -> Table scan on small_tab  (rows=4)
                -> Hash
                    -> Table scan on medium_tab  (rows=3)

EXPLAIN FORMAT=TREE SELECT COUNT(*) FROM medium_tab STRAIGHT_JOIN large_tab USING(val) STRAIGHT_JOIN small_tab USING(val);
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Inner hash join (large_tab.val = small_tab.val)  (rows=0.36)
        -> Table scan on small_tab  (rows=4)
        -> Hash
            -> Inner hash join (medium_tab.val = large_tab.val)  (rows=0.9)
                -> Table scan on large_tab  (rows=3)
                -> Hash
                    -> Table scan on medium_tab  (rows=3)

EXPLAIN FORMAT=TREE SELECT COUNT(*) FROM large_tab STRAIGHT_JOIN small_tab STRAIGHT_JOIN medium_tab;
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Inner hash join (no condition)  (rows=36)
        -> Table scan on medium_tab  (rows=3)
        -> Hash
            -> Inner hash join (no condition)  (rows=12)
                -> Table scan on small_tab  (rows=4)
                -> Hash
                    -> Table scan on large_tab  (rows=3)

EXPLAIN FORMAT=TREE SELECT COUNT(*) FROM large_tab STRAIGHT_JOIN medium_tab STRAIGHT_JOIN small_tab;
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Inner hash join (no condition)  (rows=36)
        -> Table scan on small_tab  (rows=4)
        -> Hash
            -> Inner hash join (no condition)  (rows=9)
                -> Table scan on medium_tab  (rows=3)
                -> Hash
                    -> Table scan on large_tab  (rows=3)

DROP TABLE small_tab, medium_tab, large_tab;
CREATE TABLE t1 (id int, val int);
CREATE TABLE t2 (id int, val int);
CREATE TABLE t3 (id int, val int);
CREATE TABLE t4 (id int, val int);
CREATE TABLE t5 (id int, val int);
CREATE TABLE t6 (id int, val int);
JOIN_PREFIX hint
EXPLAIN FORMAT=TREE SELECT /*+ JOIN_PREFIX(t1,t3,t5) */ COUNT(*) FROM t1 JOIN t2 USING(val) JOIN t3 USING(val) JOIN t4 USING(val) JOIN t5 USING(val) JOIN t6 USING(val);
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Inner hash join (t2.val = t6.val)  (rows=10e-6)
        -> Table scan on t6  (rows=1)
        -> Hash
            -> Inner hash join (t2.val = t4.val)  (rows=100e-6)
                -> Table scan on t4  (rows=1)
                -> Hash
                    -> Inner hash join (t3.val = t2.val)  (rows=0.001)
                        -> Table scan on t2  (rows=1)
                        -> Hash
                            -> Inner hash join (t3.val = t5.val)  (rows=0.01)
                                -> Table scan on t5  (rows=1)
                                -> Hash
                                    -> Inner hash join (t1.val = t3.val)  (rows=0.1)
                                        -> Table scan on t3  (rows=1)
                                        -> Hash
                                            -> Table scan on t1  (rows=1)

EXPLAIN FORMAT=TREE SELECT /*+ JOIN_PREFIX(t5,t4) */ COUNT(*) FROM t1 JOIN t2 USING(val) JOIN t3 USING(val) JOIN t4 USING(val) JOIN t5 USING(val) JOIN t6 USING(val);
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Inner hash join (t2.val = t6.val)  (rows=10e-6)
        -> Table scan on t6  (rows=1)
        -> Hash
            -> Inner hash join (t2.val = t3.val)  (rows=100e-6)
                -> Table scan on t3  (rows=1)
                -> Hash
                    -> Inner hash join (t4.val = t2.val)  (rows=0.001)
                        -> Table scan on t2  (rows=1)
                        -> Hash
                            -> Inner hash join (t4.val = t1.val)  (rows=0.01)
                                -> Table scan on t1  (rows=1)
                                -> Hash
                                    -> Inner hash join (t5.val = t4.val)  (rows=0.1)
                                        -> Table scan on t4  (rows=1)
                                        -> Hash
                                            -> Table scan on t5  (rows=1)

EXPLAIN FORMAT=TREE SELECT /*+ JOIN_PREFIX(t2,t4,t6,t1,t3) */ COUNT(*) FROM t1 JOIN t2 USING(val) JOIN t3 USING(val) JOIN t4 USING(val) JOIN t5 USING(val) JOIN t6 USING(val);
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Inner hash join (t2.val = t5.val)  (rows=10e-6)
        -> Table scan on t5  (rows=1)
        -> Hash
            -> Inner hash join (t2.val = t3.val)  (rows=100e-6)
                -> Table scan on t3  (rows=1)
                -> Hash
                    -> Inner hash join (t2.val = t1.val)  (rows=0.001)
                        -> Table scan on t1  (rows=1)
                        -> Hash
                            -> Inner hash join (t2.val = t6.val)  (rows=0.01)
                                -> Table scan on t6  (rows=1)
                                -> Hash
                                    -> Inner hash join (t2.val = t4.val)  (rows=0.1)
                                        -> Table scan on t4  (rows=1)
                                        -> Hash
                                            -> Table scan on t2  (rows=1)

EXPLAIN FORMAT=TREE SELECT /*+ JOIN_PREFIX(t5,t2,t1) */ COUNT(*) FROM t1 JOIN t2 JOIN t3 JOIN t4 JOIN t5 JOIN t6;
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Inner hash join (no condition)  (rows=1)
        -> Table scan on t6  (rows=1)
        -> Hash
            -> Inner hash join (no condition)  (rows=1)
                -> Table scan on t4  (rows=1)
                -> Hash
                    -> Inner hash join (no condition)  (rows=1)
                        -> Table scan on t3  (rows=1)
                        -> Hash
                            -> Inner hash join (no condition)  (rows=1)
                                -> Table scan on t1  (rows=1)
                                -> Hash
                                    -> Inner hash join (no condition)  (rows=1)
                                        -> Table scan on t2  (rows=1)
                                        -> Hash
                                            -> Table scan on t5  (rows=1)

EXPLAIN FORMAT=TREE SELECT /*+ JOIN_PREFIX(t3,t4) */ COUNT(*) FROM t1 JOIN t2 JOIN t3 JOIN t4 JOIN t5 JOIN t6;
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Inner hash join (no condition)  (rows=1)
        -> Table scan on t6  (rows=1)
        -> Hash
            -> Inner hash join (no condition)  (rows=1)
                -> Table scan on t5  (rows=1)
                -> Hash
                    -> Inner hash join (no condition)  (rows=1)
                        -> Table scan on t2  (rows=1)
                        -> Hash
                            -> Inner hash join (no condition)  (rows=1)
                                -> Table scan on t1  (rows=1)
                                -> Hash
                                    -> Inner hash join (no condition)  (rows=1)
                                        -> Table scan on t4  (rows=1)
                                        -> Hash
                                            -> Table scan on t3  (rows=1)

EXPLAIN FORMAT=TREE SELECT /*+ JOIN_PREFIX(t5,t3,t1,t2,t4) */ COUNT(*) FROM t1 JOIN t2 JOIN t3 JOIN t4 JOIN t5 JOIN t6;
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Inner hash join (no condition)  (rows=1)
        -> Table scan on t6  (rows=1)
        -> Hash
            -> Inner hash join (no condition)  (rows=1)
                -> Table scan on t4  (rows=1)
                -> Hash
                    -> Inner hash join (no condition)  (rows=1)
                        -> Table scan on t2  (rows=1)
                        -> Hash
                            -> Inner hash join (no condition)  (rows=1)
                                -> Table scan on t1  (rows=1)
                                -> Hash
                                    -> Inner hash join (no condition)  (rows=1)
                                        -> Table scan on t3  (rows=1)
                                        -> Hash
                                            -> Table scan on t5  (rows=1)

JOIN_SUFFIX hint
EXPLAIN FORMAT=TREE SELECT /*+ JOIN_SUFFIX(t1,t2,t6) */ COUNT(*) FROM t1 JOIN t2 USING(val) JOIN t3 USING(val) JOIN t4 USING(val) JOIN t5 USING(val) JOIN t6 USING(val);
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Inner hash join (t2.val = t6.val)  (rows=10e-6)
        -> Table scan on t6  (rows=1)
        -> Hash
            -> Inner hash join (t3.val = t2.val)  (rows=100e-6)
                -> Table scan on t2  (rows=1)
                -> Hash
                    -> Inner hash join (t3.val = t1.val)  (rows=0.001)
                        -> Table scan on t1  (rows=1)
                        -> Hash
                            -> Inner hash join (t3.val = t4.val)  (rows=0.01)
                                -> Table scan on t4  (rows=1)
                                -> Hash
                                    -> Inner hash join (t3.val = t5.val)  (rows=0.1)
                                        -> Table scan on t3  (rows=1)
                                        -> Hash
                                            -> Table scan on t5  (rows=1)

EXPLAIN FORMAT=TREE SELECT /*+ JOIN_SUFFIX(t6,t3) */ COUNT(*) FROM t1 JOIN t2 USING(val) JOIN t3 USING(val) JOIN t4 USING(val) JOIN t5 USING(val) JOIN t6 USING(val);
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Inner hash join (t2.val = t3.val)  (rows=10e-6)
        -> Table scan on t3  (rows=1)
        -> Hash
            -> Inner hash join (t2.val = t6.val)  (rows=100e-6)
                -> Table scan on t6  (rows=1)
                -> Hash
                    -> Inner hash join (t1.val = t2.val)  (rows=0.001)
                        -> Table scan on t1  (rows=1)
                        -> Hash
                            -> Inner hash join (t2.val = t4.val)  (rows=0.01)
                                -> Table scan on t4  (rows=1)
                                -> Hash
                                    -> Inner hash join (t2.val = t5.val)  (rows=0.1)
                                        -> Table scan on t2  (rows=1)
                                        -> Hash
                                            -> Table scan on t5  (rows=1)

EXPLAIN FORMAT=TREE SELECT /*+ JOIN_SUFFIX(t5,t4,t3,t6,t1) */ COUNT(*) FROM t1 JOIN t2 USING(val) JOIN t3 USING(val) JOIN t4 USING(val) JOIN t5 USING(val) JOIN t6 USING(val);
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Inner hash join (t2.val = t1.val)  (rows=10e-6)
        -> Table scan on t1  (rows=1)
        -> Hash
            -> Inner hash join (t2.val = t6.val)  (rows=100e-6)
                -> Table scan on t6  (rows=1)
                -> Hash
                    -> Inner hash join (t2.val = t3.val)  (rows=0.001)
                        -> Table scan on t3  (rows=1)
                        -> Hash
                            -> Inner hash join (t2.val = t4.val)  (rows=0.01)
                                -> Table scan on t4  (rows=1)
                                -> Hash
                                    -> Inner hash join (t2.val = t5.val)  (rows=0.1)
                                        -> Table scan on t5  (rows=1)
                                        -> Hash
                                            -> Table scan on t2  (rows=1)

EXPLAIN FORMAT=TREE SELECT /*+ JOIN_SUFFIX(t4,t5,t2) */ COUNT(*) FROM t1 JOIN t2 JOIN t3 JOIN t4 JOIN t5 JOIN t6;
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Inner hash join (no condition)  (rows=1)
        -> Table scan on t2  (rows=1)
        -> Hash
            -> Inner hash join (no condition)  (rows=1)
                -> Table scan on t5  (rows=1)
                -> Hash
                    -> Inner hash join (no condition)  (rows=1)
                        -> Table scan on t4  (rows=1)
                        -> Hash
                            -> Inner hash join (no condition)  (rows=1)
                                -> Inner hash join (no condition)  (rows=1)
                                    -> Table scan on t1  (rows=1)
                                    -> Hash
                                        -> Table scan on t3  (rows=1)
                                -> Hash
                                    -> Table scan on t6  (rows=1)

EXPLAIN FORMAT=TREE SELECT /*+ JOIN_SUFFIX(t3,t2) */ COUNT(*) FROM t1 JOIN t2 JOIN t3 JOIN t4 JOIN t5 JOIN t6;
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Inner hash join (no condition)  (rows=1)
        -> Table scan on t2  (rows=1)
        -> Hash
            -> Inner hash join (no condition)  (rows=1)
                -> Table scan on t3  (rows=1)
                -> Hash
                    -> Inner hash join (no condition)  (rows=1)
                        -> Inner hash join (no condition)  (rows=1)
                            -> Inner hash join (no condition)  (rows=1)
                                -> Table scan on t1  (rows=1)
                                -> Hash
                                    -> Table scan on t4  (rows=1)
                            -> Hash
                                -> Table scan on t5  (rows=1)
                        -> Hash
                            -> Table scan on t6  (rows=1)

EXPLAIN FORMAT=TREE SELECT /*+ JOIN_SUFFIX(t1,t3,t2,t5,t4) */ COUNT(*) FROM t1 JOIN t2 JOIN t3 JOIN t4 JOIN t5 JOIN t6;
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Inner hash join (no condition)  (rows=1)
        -> Table scan on t4  (rows=1)
        -> Hash
            -> Inner hash join (no condition)  (rows=1)
                -> Table scan on t5  (rows=1)
                -> Hash
                    -> Inner hash join (no condition)  (rows=1)
                        -> Table scan on t2  (rows=1)
                        -> Hash
                            -> Inner hash join (no condition)  (rows=1)
                                -> Table scan on t3  (rows=1)
                                -> Hash
                                    -> Inner hash join (no condition)  (rows=1)
                                        -> Table scan on t1  (rows=1)
                                        -> Hash
                                            -> Table scan on t6  (rows=1)

JOIN_ORDER hint
EXPLAIN FORMAT=TREE SELECT /*+ JOIN_ORDER(t6,t1) */ COUNT(*) FROM t1 JOIN t2 JOIN t3 JOIN t4 JOIN t5 JOIN t6;
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Inner hash join (no condition)  (rows=1)
        -> Table scan on t1  (rows=1)
        -> Hash
            -> Inner hash join (no condition)  (rows=1)
                -> Inner hash join (no condition)  (rows=1)
                    -> Inner hash join (no condition)  (rows=1)
                        -> Inner hash join (no condition)  (rows=1)
                            -> Table scan on t6  (rows=1)
                            -> Hash
                                -> Table scan on t2  (rows=1)
                        -> Hash
                            -> Table scan on t3  (rows=1)
                    -> Hash
                        -> Table scan on t4  (rows=1)
                -> Hash
                    -> Table scan on t5  (rows=1)

EXPLAIN FORMAT=TREE SELECT /*+ JOIN_ORDER(t4,t6,t3,t5,t1) */ COUNT(*) FROM t1 JOIN t2 JOIN t3 JOIN t4 JOIN t5 JOIN t6;
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Inner hash join (no condition)  (rows=1)
        -> Table scan on t1  (rows=1)
        -> Hash
            -> Inner hash join (no condition)  (rows=1)
                -> Table scan on t5  (rows=1)
                -> Hash
                    -> Inner hash join (no condition)  (rows=1)
                        -> Table scan on t3  (rows=1)
                        -> Hash
                            -> Inner hash join (no condition)  (rows=1)
                                -> Table scan on t6  (rows=1)
                                -> Hash
                                    -> Inner hash join (no condition)  (rows=1)
                                        -> Table scan on t4  (rows=1)
                                        -> Hash
                                            -> Table scan on t2  (rows=1)

Nested tables as hint tables
EXPLAIN FORMAT=TREE SELECT /*+ QB_NAME(q1) JOIN_PREFIX(t2,t1,t2@subq2) */ count(*) FROM t1 JOIN t2 JOIN t3
WHERE t1.val IN (SELECT /*+ QB_NAME(subq1) */ val FROM t2) AND
t2.val IN (SELECT /*+ QB_NAME(subq2) */ val FROM t2);
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Hash semijoin (FirstMatch) (t1.val = t2.val)  (rows=0.01)
        -> Inner hash join (no condition)  (rows=0.1)
            -> Table scan on t3  (rows=1)
            -> Hash
                -> Hash semijoin (FirstMatch) (t2.val = t2.val)  (rows=0.1)
                    -> Inner hash join (no condition)  (rows=1)
                        -> Table scan on t1  (rows=1)
                        -> Hash
                            -> Table scan on t2  (rows=1)
                    -> Hash
                        -> Table scan on t2  (rows=1)
        -> Hash
            -> Table scan on t2  (rows=1)

EXPLAIN FORMAT=TREE SELECT /*+ JOIN_PREFIX(t2,t1) JOIN_ORDER(t3,t4@subq1) JOIN_SUFFIX(t4@subq1) */ count(*) FROM t1 JOIN t2 JOIN t3
WHERE t1.val IN (SELECT /*+ QB_NAME(subq1) */ t4.val FROM t4 JOIN t5);
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Hash semijoin (FirstMatch) (t1.val = t4.val)  (rows=0.1)
        -> Inner hash join (no condition)  (rows=1)
            -> Table scan on t3  (rows=1)
            -> Hash
                -> Inner hash join (no condition)  (rows=1)
                    -> Table scan on t1  (rows=1)
                    -> Hash
                        -> Table scan on t2  (rows=1)
        -> Hash
            -> Inner hash join (no condition)  (rows=1)
                -> Table scan on t4  (rows=1)
                -> Hash
                    -> Table scan on t5  (rows=1)

EXPLAIN FORMAT=TREE SELECT /*+ JOIN_SUFFIX(t5@subq2) */ count(*)
FROM t1 JOIN t2 JOIN t3
WHERE t1.val IN (SELECT /*+ QB_NAME(subq1) */ val FROM t4)
AND t2.val IN (SELECT /*+ QB_NAME(subq2) */ val FROM t5);
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Inner hash join (no condition)  (rows=0.01)
        -> Table scan on t3  (rows=1)
        -> Hash
            -> Inner hash join (no condition)  (rows=0.01)
                -> Hash semijoin (FirstMatch) (t1.val = t4.val)  (rows=0.1)
                    -> Table scan on t1  (rows=1)
                    -> Hash
                        -> Table scan on t4  (rows=1)
                -> Hash
                    -> Hash semijoin (FirstMatch) (t2.val = t5.val)  (rows=0.1)
                        -> Table scan on t2  (rows=1)
                        -> Hash
                            -> Table scan on t5  (rows=1)

EXPLAIN FORMAT=TREE SELECT /*+ JOIN_ORDER(t5@subq2,t4@subq1) JOIN_PREFIX(t1) JOIN_SUFFIX(t2,t5@subq2,t4@subq1) */ count(*)
FROM t1 JOIN t2 JOIN t3
WHERE t1.val IN (SELECT /*+ QB_NAME(subq1) */ val FROM t4)
AND t2.val IN (SELECT /*+ QB_NAME(subq2) */ val FROM t5);
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Hash semijoin (FirstMatch) (t1.val = t4.val)  (rows=0.01)
        -> Hash semijoin (FirstMatch) (t2.val = t5.val)  (rows=0.1)
            -> Inner hash join (no condition)  (rows=1)
                -> Table scan on t2  (rows=1)
                -> Hash
                    -> Inner hash join (no condition)  (rows=1)
                        -> Table scan on t3  (rows=1)
                        -> Hash
                            -> Table scan on t1  (rows=1)
            -> Hash
                -> Table scan on t5  (rows=1)
        -> Hash
            -> Table scan on t4  (rows=1)

EXPLAIN FORMAT=TREE SELECT /*+ QB_NAME(q1) JOIN_ORDER(@q1 t2,t3,t1) */ count(*)
FROM t1 JOIN t2 JOIN t3
WHERE t1.val IN (SELECT /*+ QB_NAME(subq1) */ val FROM t4)
AND t2.val IN (SELECT /*+ QB_NAME(subq2) */ val FROM t5);
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Hash semijoin (FirstMatch) (t2.val = t5.val)  (rows=0.01)
        -> Hash semijoin (FirstMatch) (t1.val = t4.val)  (rows=0.1)
            -> Inner hash join (no condition)  (rows=1)
                -> Table scan on t1  (rows=1)
                -> Hash
                    -> Inner hash join (no condition)  (rows=1)
                        -> Table scan on t3  (rows=1)
                        -> Hash
                            -> Table scan on t2  (rows=1)
            -> Hash
                -> Table scan on t4  (rows=1)
        -> Hash
            -> Table scan on t5  (rows=1)

EXPLAIN FORMAT=TREE SELECT /*+ QB_NAME(q1) JOIN_PREFIX(@q1 t2,t3,t1) */ count(*)
FROM t1 JOIN t2 JOIN t3
WHERE t1.val IN (SELECT /*+ QB_NAME(subq1) */ val FROM t4)
AND t2.val IN (SELECT /*+ QB_NAME(subq2) */ val FROM t5);
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Hash semijoin (FirstMatch) (t2.val = t5.val)  (rows=0.01)
        -> Hash semijoin (FirstMatch) (t1.val = t4.val)  (rows=0.1)
            -> Inner hash join (no condition)  (rows=1)
                -> Table scan on t1  (rows=1)
                -> Hash
                    -> Inner hash join (no condition)  (rows=1)
                        -> Table scan on t3  (rows=1)
                        -> Hash
                            -> Table scan on t2  (rows=1)
            -> Hash
                -> Table scan on t4  (rows=1)
        -> Hash
            -> Table scan on t5  (rows=1)

Multiple hints,all applicable
EXPLAIN FORMAT=TREE SELECT /*+ JOIN_PREFIX(t1,t2,t3) */ count(*) FROM t1 JOIN t2 STRAIGHT_JOIN t3
WHERE t1.val IN (SELECT val FROM t4) AND t2.val IN (SELECT val FROM t5);
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Hash semijoin (FirstMatch) (t2.val = t5.val)  (rows=0.01)
        -> Hash semijoin (FirstMatch) (t1.val = t4.val)  (rows=0.1)
            -> Inner hash join (no condition)  (rows=1)
                -> Table scan on t3  (rows=1)
                -> Hash
                    -> Inner hash join (no condition)  (rows=1)
                        -> Table scan on t2  (rows=1)
                        -> Hash
                            -> Table scan on t1  (rows=1)
            -> Hash
                -> Table scan on t4  (rows=1)
        -> Hash
            -> Table scan on t5  (rows=1)

EXPLAIN FORMAT=TREE SELECT /*+ JOIN_PREFIX(t3) JOIN_ORDER(t1,t2,t5) */ count(*) FROM t1 JOIN t2 JOIN t3
WHERE t1.val IN (SELECT /*+ QB_NAME(subq1) */ val FROM t4)
AND t2.val IN (SELECT /*+ QB_NAME(subq2) */ val FROM t5);
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Hash semijoin (FirstMatch) (t2.val = t5.val)  (rows=0.01)
        -> Hash semijoin (FirstMatch) (t1.val = t4.val)  (rows=0.1)
            -> Inner hash join (no condition)  (rows=1)
                -> Table scan on t2  (rows=1)
                -> Hash
                    -> Inner hash join (no condition)  (rows=1)
                        -> Table scan on t1  (rows=1)
                        -> Hash
                            -> Table scan on t3  (rows=1)
            -> Hash
                -> Table scan on t4  (rows=1)
        -> Hash
            -> Table scan on t5  (rows=1)

EXPLAIN FORMAT=TREE  SELECT /*+ JOIN_ORDER(t3,t2) JOIN_ORDER(t1,t2,t5) */ count(*) FROM t1 JOIN t2 JOIN t3 JOIN t4 JOIN t5;
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Inner hash join (no condition)  (rows=1)
        -> Table scan on t5  (rows=1)
        -> Hash
            -> Inner hash join (no condition)  (rows=1)
                -> Inner hash join (no condition)  (rows=1)
                    -> Table scan on t2  (rows=1)
                    -> Hash
                        -> Inner hash join (no condition)  (rows=1)
                            -> Table scan on t3  (rows=1)
                            -> Hash
                                -> Table scan on t1  (rows=1)
                -> Hash
                    -> Table scan on t4  (rows=1)

EXPLAIN FORMAT=TREE  SELECT /*+ JOIN_ORDER(t3,t2,t1,t6) JOIN_ORDER(t4,t2,t5,t1) */ count(*) FROM t1 JOIN t2 JOIN t3 JOIN t4 JOIN t5 JOIN t6;
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Inner hash join (no condition)  (rows=1)
        -> Table scan on t6  (rows=1)
        -> Hash
            -> Inner hash join (no condition)  (rows=1)
                -> Table scan on t1  (rows=1)
                -> Hash
                    -> Inner hash join (no condition)  (rows=1)
                        -> Table scan on t5  (rows=1)
                        -> Hash
                            -> Inner hash join (no condition)  (rows=1)
                                -> Table scan on t2  (rows=1)
                                -> Hash
                                    -> Inner hash join (no condition)  (rows=1)
                                        -> Table scan on t3  (rows=1)
                                        -> Hash
                                            -> Table scan on t4  (rows=1)

Conflicting hints
EXPLAIN FORMAT=TREE SELECT /*+ JOIN_PREFIX(t3,t2,t1) JOIN_PREFIX(t2,t1) */ count(*) FROM t1 JOIN t2 JOIN t3
WHERE t1.val IN (SELECT /*+ QB_NAME(subq1) */ val FROM t4)
AND t2.val IN (SELECT /*+ QB_NAME(subq2) */ val FROM t5);
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Hash semijoin (FirstMatch) (t2.val = t5.val)  (rows=0.01)
        -> Hash semijoin (FirstMatch) (t1.val = t4.val)  (rows=0.1)
            -> Inner hash join (no condition)  (rows=1)
                -> Table scan on t1  (rows=1)
                -> Hash
                    -> Inner hash join (no condition)  (rows=1)
                        -> Table scan on t2  (rows=1)
                        -> Hash
                            -> Table scan on t3  (rows=1)
            -> Hash
                -> Table scan on t4  (rows=1)
        -> Hash
            -> Table scan on t5  (rows=1)

Warnings:
Warning	3126	Hint JOIN_PREFIX( `t2`,`t1`) is ignored as conflicting/duplicated
EXPLAIN FORMAT=TREE SELECT /*+ JOIN_SUFFIX(t3,t2) JOIN_SUFFIX(t2) */ count(*) FROM t1 JOIN t2 JOIN t3
WHERE t1.val IN (SELECT /*+ QB_NAME(subq1) */ val FROM t4)
AND t2.val IN (SELECT /*+ QB_NAME(subq2) */ val FROM t5);
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Hash semijoin (FirstMatch) (t2.val = t5.val)  (rows=0.01)
        -> Hash semijoin (FirstMatch) (t1.val = t4.val)  (rows=0.1)
            -> Inner hash join (no condition)  (rows=1)
                -> Table scan on t3  (rows=1)
                -> Hash
                    -> Inner hash join (no condition)  (rows=1)
                        -> Table scan on t1  (rows=1)
                        -> Hash
                            -> Table scan on t2  (rows=1)
            -> Hash
                -> Table scan on t4  (rows=1)
        -> Hash
            -> Table scan on t5  (rows=1)

Warnings:
Warning	3126	Hint JOIN_SUFFIX( `t2`) is ignored as conflicting/duplicated
Warning	3515	Hints aren't supported in hypergraph: semijoin/antijoin table precedes a table which it depends on
EXPLAIN FORMAT=TREE SELECT /*+ JOIN_FIXED_ORDER() JOIN_ORDER(t2,t1) */ t2.val FROM t1 JOIN t2 ON t1.val = t2.val
WHERE (t1.val > 5 AND t1.val <= 5);
EXPLAIN
-> Inner hash join (t1.val = t2.val)  (rows=0.0111)
    -> Table scan on t2  (rows=1)
    -> Hash
        -> Filter: ((t1.val > 5) and (t1.val <= 5))  (rows=0.111)
            -> Table scan on t1  (rows=1)

Warnings:
Warning	3126	Hint JOIN_ORDER( `t2`,`t1`) is ignored as conflicting/duplicated
EXPLAIN FORMAT=TREE SELECT /*+ JOIN_ORDER(t3,t2) JOIN_ORDER(t2,t3) */ count(*) FROM t1 JOIN t2 JOIN t3;
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Inner hash join (no condition)  (rows=1)
        -> Table scan on t2  (rows=1)
        -> Hash
            -> Inner hash join (no condition)  (rows=1)
                -> Table scan on t1  (rows=1)
                -> Hash
                    -> Table scan on t3  (rows=1)

Invalid hint which places semijoin table at beginning of table list
EXPLAIN FORMAT=TREE SELECT /*+ JOIN_PREFIX(t5@subq1,t4@subq1,t2) */ count(*)
FROM t1 JOIN t2 JOIN t3
WHERE t1.val IN (SELECT /*+ QB_NAME(subq1) */ t4.val FROM t4 JOIN t5);
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Inner hash join (no condition)  (rows=0.1)
        -> Table scan on t3  (rows=1)
        -> Hash
            -> Inner hash join (no condition)  (rows=0.1)
                -> Table scan on t2  (rows=1)
                -> Hash
                    -> Hash semijoin (FirstMatch) (t1.val = t4.val)  (rows=0.1)
                        -> Table scan on t1  (rows=1)
                        -> Hash
                            -> Inner hash join (no condition)  (rows=1)
                                -> Table scan on t5  (rows=1)
                                -> Hash
                                    -> Table scan on t4  (rows=1)

Warnings:
Warning	3515	Hints aren't supported in hypergraph: first table in join order cannot be semijoin/antijoin nest
DROP TABLE t1, t2, t3, t4, t5, t6;
Outer joins with hints
CREATE TABLE t1(val INT NOT NULL AUTO_INCREMENT,PRIMARY KEY(val));
CREATE TABLE t2(val INT DEFAULT NULL);
CREATE TABLE t3(val INT DEFAULT NULL);
Applicable hint
EXPLAIN FORMAT=TREE DELETE /*+ JOIN_PREFIX(t2,t3,ta2) */
FROM ta1.* USING t1 AS ta1 JOIN t1 AS ta2 ON 1
RIGHT OUTER JOIN t2 ON (ta1.val = t2.val)
WHERE (9) IN (SELECT val FROM t3);
EXPLAIN
-> Delete from ta1 (buffered)  (rows=0.1)
    -> Left hash join (ta1.val = t2.val)  (rows=0.1)
        -> Hash semijoin (FirstMatch) (no condition)  (rows=0.1)
            -> Table scan on t2  (rows=1)
            -> Hash
                -> Filter: (t3.val = 9)  (rows=0.1)
                    -> Table scan on t3  (rows=1)
        -> Hash
            -> Inner hash join (no condition)  (rows=1)
                -> Table scan on ta2  (rows=1)
                -> Hash
                    -> Table scan on ta1  (rows=1)

Hint should be ignored
EXPLAIN FORMAT=TREE DELETE /*+ JOIN_SUFFIX(ta2,t3,ta1) */
FROM ta1.* USING t1 AS ta1 JOIN t1 AS ta2 ON 1
RIGHT OUTER JOIN t2 ON (ta1.val = t2.val)
WHERE (9) IN (SELECT val FROM t3);
EXPLAIN
-> Delete from ta1 (buffered)  (rows=0.1)
    -> Hash semijoin (FirstMatch) (no condition)  (rows=0.1)
        -> Left hash join (ta1.val = t2.val)  (rows=1)
            -> Table scan on t2  (rows=1)
            -> Hash
                -> Inner hash join (no condition)  (rows=1)
                    -> Table scan on ta2  (rows=1)
                    -> Hash
                        -> Table scan on ta1  (rows=1)
        -> Hash
            -> Filter: (t3.val = 9)  (rows=0.1)
                -> Table scan on t3  (rows=1)

Both hints should be ignored
EXPLAIN FORMAT=TREE DELETE /*+ JOIN_PREFIX(ta1,t2,t3) JOIN_SUFFIX(t3,ta2) */
FROM ta1.* USING t1 AS ta1 JOIN t1 AS ta2 ON 1
RIGHT OUTER JOIN t2 ON (ta1.val = t2.val)
WHERE (9) IN (SELECT val FROM t3);
EXPLAIN
-> Delete from ta1 (buffered)  (rows=0.1)
    -> Left hash join (ta1.val = t2.val)  (rows=0.1)
        -> Hash semijoin (FirstMatch) (no condition)  (rows=0.1)
            -> Table scan on t2  (rows=1)
            -> Hash
                -> Filter: (t3.val = 9)  (rows=0.1)
                    -> Table scan on t3  (rows=1)
        -> Hash
            -> Inner hash join (no condition)  (rows=1)
                -> Table scan on ta1  (rows=1)
                -> Hash
                    -> Table scan on ta2  (rows=1)

Warnings:
Warning	3515	Hints aren't supported in hypergraph: first table in join order cannot be semijoin/antijoin nest
Lateral joins with hints
# Applicable hint
EXPLAIN FORMAT=TREE SELECT /*+ JOIN_PREFIX(t1) */ 1 FROM t1,LATERAL (SELECT DISTINCT t2.val FROM t2 WHERE t1.val = t2.val) AS dt;
EXPLAIN
-> Nested loop inner join  (rows=1)
    -> Table scan on t1  (rows=1)
    -> Stream results  (rows=1)
        -> Sort with duplicate removal: t2.val  (rows=1)
            -> Filter: (t1.val = t2.val)  (rows=1)
                -> Table scan on t2  (rows=1)

Warnings:
Note	1276	Field or reference 'test.t1.val' of SELECT #2 was resolved in SELECT #1
# Hint ignored, hypergraph retries optimization after deleting hint
EXPLAIN FORMAT=TREE SELECT /*+ JOIN_PREFIX(dt) */ 1 FROM t1,LATERAL (SELECT DISTINCT t2.val FROM t2 WHERE t1.val = t2.val) AS dt;
EXPLAIN
-> Nested loop inner join  (rows=1)
    -> Table scan on t1  (rows=1)
    -> Stream results  (rows=1)
        -> Sort with duplicate removal: t2.val  (rows=1)
            -> Filter: (t1.val = t2.val)  (rows=1)
                -> Table scan on t2  (rows=1)

Warnings:
Note	1276	Field or reference 'test.t1.val' of SELECT #2 was resolved in SELECT #1
DROP TABLE t1,t2,t3;
Bug#36533749 WL#15853:Element_type& mem_root_deque<Element_type>: Assertion `!empty()' failed
CREATE TABLE t1 (f1 INT NOT NULL);
INSERT INTO t1 VALUES (9),(0), (7);
CREATE TABLE t2 (f1 INT NOT NULL);
INSERT INTO t2 VALUES
(5),(3),(0),(3),(1),(0),(1),(7),(1),(0),(0),(8),(4),(9),(0),(2),(0),(8),(5),(1);
CREATE TABLE t3 (f1 INT NOT NULL);
INSERT INTO t3 VALUES (9),(0), (7), (4), (5);
CREATE TABLE t4 (f1 INT NOT NULL);
INSERT INTO t4 VALUES (0), (7);
CREATE TABLE t5 (f1 INT NOT NULL, PRIMARY KEY(f1));
INSERT INTO t5 VALUES (7);
ANALYZE TABLE t1, t2, t3, t4, t5;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
test.t3	analyze	status	OK
test.t4	analyze	status	OK
test.t5	analyze	status	OK
# Both hints applicable
EXPLAIN FORMAT=TREE SELECT /*+ JOIN_ORDER(t3,t2) JOIN_PREFIX(t3) */ count(*) FROM t1 JOIN t2 JOIN t3 WHERE t1.f1 IN (SELECT f1 FROM t4) AND t2.f1 IN (SELECT f1 FROM t5);
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Hash semijoin (FirstMatch) (t2.f1 = t5.f1)  (rows=42.4)
        -> Hash semijoin (FirstMatch) (t1.f1 = t4.f1)  (rows=42.4)
            -> Inner hash join (no condition)  (rows=300)
                -> Table scan on t2  (rows=20)
                -> Hash
                    -> Inner hash join (no condition)  (rows=15)
                        -> Table scan on t1  (rows=3)
                        -> Hash
                            -> Table scan on t3  (rows=5)
            -> Hash
                -> Table scan on t4  (rows=2)
        -> Hash
            -> Table scan on t5  (rows=1)

EXPLAIN FORMAT=TREE SELECT /*+ JOIN_ORDER(t3,t2) JOIN_SUFFIX(t2) */ count(*) FROM t1 JOIN t2 JOIN t3 WHERE t1.f1 IN (SELECT f1 FROM t4) AND t2.f1 IN (SELECT f1 FROM t5);
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Inner hash join (no condition)  (rows=42.4)
        -> Hash semijoin (FirstMatch) (t2.f1 = t5.f1)  (rows=8.49)
            -> Hash semijoin (FirstMatch) (t1.f1 = t4.f1)  (rows=8.49)
                -> Inner hash join (no condition)  (rows=60)
                    -> Table scan on t2  (rows=20)
                    -> Hash
                        -> Table scan on t1  (rows=3)
                -> Hash
                    -> Table scan on t4  (rows=2)
            -> Hash
                -> Table scan on t5  (rows=1)
        -> Hash
            -> Table scan on t3  (rows=5)

Warnings:
Warning	3515	Hints aren't supported in hypergraph: semijoin/antijoin table precedes a table which it depends on
EXPLAIN FORMAT=TREE SELECT /*+ JOIN_ORDER(t3,t2,t4) JOIN_SUFFIX(t1,t4) */ count(*) FROM t1 JOIN t2 JOIN t3 WHERE t1.f1 IN (SELECT f1 FROM t4) AND t2.f1 IN (SELECT f1 FROM t5);
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Hash semijoin (FirstMatch) (t1.f1 = t4.f1)  (rows=42.4)
        -> Inner hash join (no condition)  (rows=300)
            -> Table scan on t1  (rows=3)
            -> Hash
                -> Hash semijoin (FirstMatch) (t2.f1 = t5.f1)  (rows=100)
                    -> Inner hash join (no condition)  (rows=100)
                        -> Table scan on t2  (rows=20)
                        -> Hash
                            -> Table scan on t3  (rows=5)
                    -> Hash
                        -> Table scan on t5  (rows=1)
        -> Hash
            -> Table scan on t4  (rows=2)

EXPLAIN FORMAT=TREE SELECT /*+ JOIN_ORDER(t1,t2,t4) JOIN_PREFIX(t1,t2) */ count(*) FROM t1 JOIN t2 JOIN t3 WHERE t1.f1 IN (SELECT f1 FROM t4) AND t2.f1 IN (SELECT f1 FROM t5);
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Hash semijoin (FirstMatch) (t2.f1 = t5.f1)  (rows=42.4)
        -> Inner hash join (no condition)  (rows=42.4)
            -> Table scan on t3  (rows=5)
            -> Hash
                -> Hash semijoin (FirstMatch) (t1.f1 = t4.f1)  (rows=8.49)
                    -> Inner hash join (no condition)  (rows=60)
                        -> Table scan on t2  (rows=20)
                        -> Hash
                            -> Table scan on t1  (rows=3)
                    -> Hash
                        -> Table scan on t4  (rows=2)
        -> Hash
            -> Table scan on t5  (rows=1)

EXPLAIN FORMAT=TREE SELECT /*+ JOIN_ORDER(t1,t2,t4) JOIN_SUFFIX(t2,t3,t4) */ count(*) FROM t1 JOIN t2 JOIN t3 WHERE t1.f1 IN (SELECT f1 FROM t4) AND t2.f1 IN (SELECT f1 FROM t5);
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Hash semijoin (FirstMatch) (t2.f1 = t5.f1)  (rows=42.4)
        -> Hash semijoin (FirstMatch) (t1.f1 = t4.f1)  (rows=42.4)
            -> Inner hash join (no condition)  (rows=300)
                -> Table scan on t3  (rows=5)
                -> Hash
                    -> Inner hash join (no condition)  (rows=60)
                        -> Table scan on t2  (rows=20)
                        -> Hash
                            -> Table scan on t1  (rows=3)
            -> Hash
                -> Table scan on t4  (rows=2)
        -> Hash
            -> Table scan on t5  (rows=1)

Warnings:
Warning	3515	Hints aren't supported in hypergraph: semijoin/antijoin table precedes a table which it depends on
# Conflicting hints
EXPLAIN FORMAT=TREE SELECT /*+ JOIN_ORDER(t3,t2) JOIN_PREFIX(t2) */ count(*) FROM t1 JOIN t2 JOIN t3 WHERE t1.f1 IN (SELECT f1 FROM t4) AND t2.f1 IN (SELECT f1 FROM t5);
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Hash semijoin (FirstMatch) (t2.f1 = t5.f1)  (rows=42.4)
        -> Hash semijoin (FirstMatch) (t1.f1 = t4.f1)  (rows=42.4)
            -> Inner hash join (no condition)  (rows=300)
                -> Table scan on t2  (rows=20)
                -> Hash
                    -> Inner hash join (no condition)  (rows=15)
                        -> Table scan on t3  (rows=5)
                        -> Hash
                            -> Table scan on t1  (rows=3)
            -> Hash
                -> Table scan on t4  (rows=2)
        -> Hash
            -> Table scan on t5  (rows=1)

EXPLAIN FORMAT=TREE SELECT /*+ JOIN_ORDER(t3,t2) JOIN_SUFFIX(t3) */ count(*) FROM t1 JOIN t2 JOIN t3 WHERE t1.f1 IN (SELECT f1 FROM t4) AND t2.f1 IN (SELECT f1 FROM t5);
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Hash semijoin (FirstMatch) (t2.f1 = t5.f1)  (rows=42.4)
        -> Hash semijoin (FirstMatch) (t1.f1 = t4.f1)  (rows=42.4)
            -> Inner hash join (no condition)  (rows=300)
                -> Table scan on t2  (rows=20)
                -> Hash
                    -> Inner hash join (no condition)  (rows=15)
                        -> Table scan on t3  (rows=5)
                        -> Hash
                            -> Table scan on t1  (rows=3)
            -> Hash
                -> Table scan on t4  (rows=2)
        -> Hash
            -> Table scan on t5  (rows=1)

EXPLAIN FORMAT=TREE SELECT /*+ JOIN_ORDER(t3,t2,t4) JOIN_PREFIX(t1,t2) */ count(*) FROM t1 JOIN t2 JOIN t3 WHERE t1.f1 IN (SELECT f1 FROM t4) AND t2.f1 IN (SELECT f1 FROM t5);
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Hash semijoin (FirstMatch) (t2.f1 = t5.f1)  (rows=42.4)
        -> Hash semijoin (FirstMatch) (t1.f1 = t4.f1)  (rows=42.4)
            -> Inner hash join (no condition)  (rows=300)
                -> Table scan on t2  (rows=20)
                -> Hash
                    -> Inner hash join (no condition)  (rows=15)
                        -> Table scan on t3  (rows=5)
                        -> Hash
                            -> Table scan on t1  (rows=3)
            -> Hash
                -> Table scan on t4  (rows=2)
        -> Hash
            -> Table scan on t5  (rows=1)

EXPLAIN FORMAT=TREE SELECT /*+ JOIN_ORDER(t3,t2,t4) JOIN_SUFFIX(t1,t2) */ count(*) FROM t1 JOIN t2 JOIN t3 WHERE t1.f1 IN (SELECT f1 FROM t4) AND t2.f1 IN (SELECT f1 FROM t5);
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Inner hash join (no condition)  (rows=42.4)
        -> Hash semijoin (FirstMatch) (t2.f1 = t5.f1)  (rows=8.49)
            -> Inner hash join (no condition)  (rows=8.49)
                -> Table scan on t2  (rows=20)
                -> Hash
                    -> Hash semijoin (FirstMatch) (t1.f1 = t4.f1)  (rows=0.424)
                        -> Table scan on t1  (rows=3)
                        -> Hash
                            -> Table scan on t4  (rows=2)
            -> Hash
                -> Table scan on t5  (rows=1)
        -> Hash
            -> Table scan on t3  (rows=5)

Warnings:
Warning	3515	Hints aren't supported in hypergraph: semijoin/antijoin table precedes a table which it depends on
EXPLAIN FORMAT=TREE SELECT /*+ JOIN_ORDER(t1,t2,t4) JOIN_PREFIX(t1,t4) */ count(*) FROM t1 JOIN t2 JOIN t3 WHERE t1.f1 IN (SELECT f1 FROM t4) AND t2.f1 IN (SELECT f1 FROM t5);
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Inner hash join (no condition)  (rows=42.4)
        -> Hash semijoin (FirstMatch) (t2.f1 = t5.f1)  (rows=8.49)
            -> Hash semijoin (FirstMatch) (t1.f1 = t4.f1)  (rows=8.49)
                -> Inner hash join (no condition)  (rows=60)
                    -> Table scan on t2  (rows=20)
                    -> Hash
                        -> Table scan on t1  (rows=3)
                -> Hash
                    -> Table scan on t4  (rows=2)
            -> Hash
                -> Table scan on t5  (rows=1)
        -> Hash
            -> Table scan on t3  (rows=5)

EXPLAIN FORMAT=TREE SELECT /*+ JOIN_ORDER(t1,t2,t4) JOIN_SUFFIX(t4,t2) */ count(*) FROM t1 JOIN t2 JOIN t3 WHERE t1.f1 IN (SELECT f1 FROM t4) AND t2.f1 IN (SELECT f1 FROM t5);
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Inner hash join (no condition)  (rows=42.4)
        -> Hash semijoin (FirstMatch) (t2.f1 = t5.f1)  (rows=8.49)
            -> Hash semijoin (FirstMatch) (t1.f1 = t4.f1)  (rows=8.49)
                -> Inner hash join (no condition)  (rows=60)
                    -> Table scan on t2  (rows=20)
                    -> Hash
                        -> Table scan on t1  (rows=3)
                -> Hash
                    -> Table scan on t4  (rows=2)
            -> Hash
                -> Table scan on t5  (rows=1)
        -> Hash
            -> Table scan on t3  (rows=5)

EXPLAIN FORMAT=TREE SELECT /*+ JOIN_ORDER(t1,t3,t2) JOIN_SUFFIX(t3,t1,t2) */ count(*) FROM t1 JOIN t2 JOIN t3 WHERE t1.f1 IN (SELECT f1 FROM t4);
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Inner hash join (no condition)  (rows=42.4)
        -> Inner hash join (no condition)  (rows=8.49)
            -> Table scan on t2  (rows=20)
            -> Hash
                -> Hash semijoin (FirstMatch) (t1.f1 = t4.f1)  (rows=0.424)
                    -> Table scan on t1  (rows=3)
                    -> Hash
                        -> Table scan on t4  (rows=2)
        -> Hash
            -> Table scan on t3  (rows=5)

EXPLAIN FORMAT=TREE SELECT /*+ JOIN_ORDER(t2,t4,t1) */ 1 FROM t1 JOIN t2 ON 1 RIGHT JOIN t3 ON 1 JOIN t4 ON 1;
EXPLAIN
-> Inner hash join (no condition)  (rows=600)
    -> Left hash join (no condition)  (rows=300)
        -> Table scan on t3  (rows=5)
        -> Hash
            -> Inner hash join (no condition)  (rows=60)
                -> Table scan on t2  (rows=20)
                -> Hash
                    -> Table scan on t1  (rows=3)
    -> Hash
        -> Table scan on t4  (rows=2)

explain format=tree SELECT /*+ JOIN_PREFIX(t3,t1) */ count(*) FROM t1 JOIN t2 STRAIGHT_JOIN t3 WHERE t1.f1 IN (SELECT f1 FROM t4) AND t2.f1 IN (SELECT f1 FROM t5);
EXPLAIN
-> Aggregate: count(0)  (rows=1)
    -> Hash semijoin (FirstMatch) (t2.f1 = t5.f1)  (rows=42.4)
        -> Hash semijoin (FirstMatch) (t1.f1 = t4.f1)  (rows=42.4)
            -> Inner hash join (no condition)  (rows=300)
                -> Table scan on t3  (rows=5)
                -> Hash
                    -> Inner hash join (no condition)  (rows=60)
                        -> Table scan on t2  (rows=20)
                        -> Hash
                            -> Table scan on t1  (rows=3)
            -> Hash
                -> Table scan on t4  (rows=2)
        -> Hash
            -> Table scan on t5  (rows=1)

DROP TABLE t1, t2, t3, t4, t5;
Bug#36533931 WL#15853: Result diff seen when using join_prefix hint
CREATE TABLE t1(f1 INT NOT NULL);
INSERT INTO t1 VALUES (10);
CREATE TABLE t2
(
f1 INT NOT NULL AUTO_INCREMENT,
f2 INT DEFAULT NULL,
PRIMARY KEY (f1),
KEY (f2)
);
INSERT INTO t2 VALUES (1, 7), (2, 1), (4, 7);
CREATE TABLE t3(f1 INT DEFAULT NULL);
INSERT INTO t3 VALUES (2);
ANALYZE TABLE t1, t2, t3;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
test.t3	analyze	status	OK
SELECT /*+ JOIN_PREFIX(t2@qb2,t3@qb1,ta3,ta4) */ COUNT(*) FROM t1 JOIN t2 AS ta3 JOIN t2 AS ta4 WHERE ta4.f1 IN (SELECT /*+ QB_NAME(qb1) */ f1 FROM t3) AND ta3.f2 IN (SELECT /*+ QB_NAME(qb2) */ f2 FROM t2);
COUNT(*)
3
Warnings:
Warning	3515	Hints aren't supported in hypergraph: first table in join order cannot be semijoin/antijoin nest
DROP TABLE t1, t2, t3;
CREATE TABLE t1 (f1 INT NOT NULL);
INSERT INTO t1 VALUES (9),(0),(7);
CREATE TABLE t2 (f1 INT NOT NULL);
INSERT INTO t2 VALUES
(5),(3),(0),(3),(1),(0),(1),(7),(1),(0),(0),(8),(4),(9),(0),(2),(0),(8),(5),(1);
CREATE TABLE t3 (f1 INT NOT NULL);
INSERT INTO t3 VALUES (9),(0),(7),(4),(5);
CREATE TABLE t4 (f1 INT NOT NULL);
INSERT INTO t4 VALUES (0),(7);
CREATE TABLE t5 (f1 INT NOT NULL, PRIMARY KEY(f1));
INSERT INTO t5 VALUES (7);
CREATE TABLE t6(f1 INT NOT NULL, PRIMARY KEY(f1));
INSERT INTO t6 VALUES (7);
ANALYZE TABLE t1, t2, t3, t4, t5, t6;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
test.t3	analyze	status	OK
test.t4	analyze	status	OK
test.t5	analyze	status	OK
test.t6	analyze	status	OK
SELECT /*+ QB_NAME(q1) JOIN_PREFIX(t3,t2,t2@subq2) */ count(*) FROM t1 JOIN t2 JOIN t3 WHERE t1.f1 IN (SELECT /*+ QB_NAME(subq1) */ f1 FROM t2) AND t2.f1 IN (SELECT /*+ QB_NAME(subq2) */ f1 FROM t2);
count(*)
300
SELECT /*+ JOIN_PREFIX(t2,t5@subq2,t4@subq1) JOIN_ORDER(t4@subq1,t3) JOIN_SUFFIX(t1) */ count(*) FROM t1 JOIN t2 JOIN t3 WHERE t1.f1 IN (SELECT /*+ QB_NAME(subq1) */ f1 FROM t4) AND t2.f1 IN (SELECT /*+ QB_NAME(subq2) */ f1 FROM t5);
count(*)
10
Warnings:
Warning	3515	Hints aren't supported in hypergraph: semijoin/antijoin table precedes a table which it depends on
SELECT /*+ JOIN_PREFIX(t1,t2) */ count(*) FROM t2 LEFT JOIN t1 on t2.f1=t1.f1;
count(*)
20
Bug#36590872 WL#15853: HG doesn't generate the warning when it specifies an unknown table
SELECT /*+ JOIN_ORDER(t1,t7,t5) */ count(*) FROM t1 JOIN t2 JOIN t3 WHERE t1.f1 IN (SELECT /*+ QB_NAME(subq1) */ f1 FROM t4) AND t2.f1 IN (SELECT /*+ QB_NAME(subq2) */ f1 FROM t5);
count(*)
10
Warnings:
Warning	3128	Unresolved name `t7` for JOIN_ORDER hint
DROP TABLE t1, t2, t3, t4, t5, t6;
Bug#36592566 WL#15853:: Assertion `table_num_to_node_num[table_num] != -1' failed.
CREATE TABLE base (pk integer auto_increment, a1 int, a2 varchar(10), a3 varchar(255), primary key(pk));
SELECT /*+ JOIN_SUFFIX(t2) */ t1.A1 AS field1 FROM base AS t1 LEFT OUTER JOIN base AS t2 ON t1.a1 = t2.pk LEFT JOIN base AS t3 ON t2.a2 = t3.a3;
field1
DROP TABLE base;
CREATE TABLE base(pk integer auto_increment, col_int int, col_int_key int, col_varchar_10_character_set_utf8mb4_key varchar(10) character set utf8mb4, col_varchar_255_character_set_latin1 varchar(255) character set latin1, primary key(pk));
SELECT/*+ JOIN_SUFFIX(alias3) */ DISTINCT SQL_SMALL_RESULT alias1.col_int AS field1, alias2.pk AS field2 FROM base AS alias1 RIGHT JOIN base AS alias2 LEFT OUTER JOIN base AS alias3 ON alias2.col_varchar_10_character_set_utf8mb4_key = alias3.col_varchar_255_character_set_latin1 ON alias1.pk = alias3.col_int_key WHERE alias3.pk >= alias2.col_int_key GROUP BY field1, field2 ORDER BY field2 ASC;
field1	field2
DROP TABLE base;
Bug#36605912 WL#15853: Assertion `!join_list.empty()' failed.
CREATE TABLE B (pk integer auto_increment, col_int int, col_int_key int, col_varchar_10_character_set_utf8mb4 varchar(10) character set utf8mb4, col_varchar_10_character_set_latin1_key varchar(10) character set latin1, primary key(pk));
SELECT /*+ JOIN_SUFFIX(alias4) */ alias1.col_int AS field4 FROM B AS alias1 LEFT JOIN B AS alias2 LEFT OUTER JOIN B AS alias3 ON alias2.col_int_key = alias3.col_int_key RIGHT JOIN B AS alias4 ON alias3.col_varchar_10_character_set_latin1_key = alias4.col_varchar_10_character_set_utf8mb4 ON alias1.pk = alias4.pk WHERE (alias4.pk IS NOT NULL OR alias3.pk != alias1.col_int);
field4
DROP TABLE B;
Bug#36604616 WL#15853: Assertion `IsMultipleEquals(cond) || IsSubset(cond->used_tables() & ~PSEUDO_TABLE_BITS, expr->tables_in_subtree)' failed.
CREATE TABLE t1(c1 mediumint DEFAULT NULL, c2 char(255) DEFAULT NULL, c3 varchar(10) DEFAULT NULL, c4 varchar(500) DEFAULT NULL, c5 char(10) DEFAULT NULL, c6 tinyint DEFAULT NULL, c7 mediumint DEFAULT NULL, c8 int DEFAULT NULL, c9 float DEFAULT NULL, pk int NOT NULL, PRIMARY KEY (pk)) ENGINE=InnoDB;
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
EXPLAIN FORMAT=TREE SELECT /*+ JOIN_ORDER(alias3,alias3,alias1) */  alias1.c1 AS field1 FROM t1 AS alias1 INNER JOIN t1 AS alias2 INNER JOIN t1 AS alias3 INNER JOIN t1 AS alias4 ON alias3.c2 >= alias4.c3 ON alias2.c4 != alias4.c5 ON alias1.c6 <= alias4.c7  LEFT OUTER JOIN t1 AS alias5 ON alias2.c8 = alias5.c9 WHERE alias3.pk <= 3 HAVING (field1 < 8 AND field1 != 8) ORDER BY field1;
EXPLAIN
-> Sort: alias1.c1  (rows=0.03)
    -> Filter: ((field1 < 8) and (field1 <> 8))  (rows=0.03)
        -> Left hash join (alias2.c8 = alias5.c9)  (rows=0.1)
            -> Inner hash join (no condition), extra conditions: (alias1.c6 <= alias4.c7) and (alias2.c4 <> alias4.c5) and (alias3.c2 >= alias4.c3)  (rows=0.1)
                -> Inner hash join (no condition)  (rows=1)
                    -> Table scan on alias1  (rows=1)
                    -> Hash
                        -> Inner hash join (no condition)  (rows=1)
                            -> Filter: (alias3.pk <= 3)  (rows=1)
                                -> Table scan on alias3  (rows=1)
                            -> Hash
                                -> Table scan on alias2  (rows=1)
                -> Hash
                    -> Table scan on alias4  (rows=1)
            -> Hash
                -> Table scan on alias5  (rows=1)

DROP TABLE t1;
Bug#36622538 WL#15853:: Assertion `table_num_to_node_num[table_num] != -1' failed.
CREATE TABLE t1 (pk integer auto_increment, col_int int, col_int_key int, col_varchar_10_character_set_latin1 varchar(10) character set latin1, col_varchar_10_character_set_latin1_key varchar(10) character set latin1, primary key(pk));
SELECT /*+ JOIN_ORDER(table1,table3,table3) JOIN_FIXED_ORDER() JOIN_ORDER(table3,table1,table2) */ table2.col_int_key AS field1, table3.col_int AS field2, table2.col_int_key AS field3, table2.pk AS field4 FROM t1 AS table1 LEFT JOIN t1 AS table2 RIGHT JOIN t1 AS table3 ON table2.col_int = table3.pk ON table1.col_varchar_10_character_set_latin1_key = table3.col_varchar_10_character_set_latin1 WHERE table3.col_int_key BETWEEN 1 AND (1 + 2) GROUP BY table2.col_int_key, table3.col_int, table2.col_int_key, table2.pk;
field1	field2	field3	field4
Warnings:
Warning	3126	Hint JOIN_FIXED_ORDER( ) is ignored as conflicting/duplicated
DROP TABLE t1;
Multiple levels of nesting
CREATE TABLE t2(f1 VARCHAR(255) DEFAULT NULL, f2 INT DEFAULT NULL, KEY (f1), KEY (f2));
CREATE TABLE t4(f1 INT DEFAULT NULL, f2 INT DEFAULT NULL, KEY (f1));
CREATE TABLE t5(f1 INT NOT NULL AUTO_INCREMENT, f2 INT DEFAULT NULL, PRIMARY KEY (f1));
CREATE TABLE t6(f1 INT NOT NULL AUTO_INCREMENT, PRIMARY KEY (f1));
CREATE TABLE t7(f1 VARCHAR(255) DEFAULT NULL);
CREATE TABLE t10(f1 INT NOT NULL AUTO_INCREMENT,f2 INT DEFAULT NULL,f3 VARCHAR(10) DEFAULT NULL, PRIMARY KEY (f1),KEY (f2),KEY (f3));
CREATE TABLE t11(f1 INT DEFAULT NULL,f2 VARCHAR(10) DEFAULT NULL, KEY (f1),KEY (f2));
ANALYZE TABLE t2, t4, t5, t6, t7, t10, t11;
Table	Op	Msg_type	Msg_text
test.t2	analyze	status	OK
test.t4	analyze	status	OK
test.t5	analyze	status	OK
test.t6	analyze	status	OK
test.t7	analyze	status	OK
test.t10	analyze	status	OK
test.t11	analyze	status	OK
EXPLAIN FORMAT=TREE SELECT /*+ JOIN_ORDER(alias11,alias8) */ 1
FROM t4 AS alias4
LEFT JOIN t5 AS alias5 JOIN t6 AS alias6 ON alias5.f2 = alias6.f1
LEFT JOIN t7 AS alias7 JOIN t2 AS alias8 ON alias7.f1 = alias8.f1
ON alias5.f1 = alias8.f2 ON alias4.f2 = alias6.f1
JOIN t10 AS alias10 JOIN t11 AS alias11 ON alias10.f1 = alias11.f1
ON alias4.f2 = alias11.f2;
EXPLAIN
-> Inner hash join (alias10.f1 = alias11.f1)  (rows=1)
    -> Table scan on alias10  (rows=1)
    -> Hash
        -> Inner hash join (cast(alias4.f2 as double) = cast(alias11.f2 as double))  (rows=1)
            -> Left hash join (alias4.f2 = alias5.f2)  (rows=1)
                -> Table scan on alias4  (rows=1)
                -> Hash
                    -> Left hash join (alias5.f1 = alias8.f2)  (rows=1)
                        -> Inner hash join (alias5.f2 = alias6.f1)  (rows=1)
                            -> Table scan on alias5  (rows=1)
                            -> Hash
                                -> Table scan on alias6  (rows=1)
                        -> Hash
                            -> Inner hash join (<hash>(alias7.f1)=<hash>(alias8.f1)), extra conditions: (alias7.f1 = alias8.f1)  (rows=1)
                                -> Table scan on alias7  (rows=1)
                                -> Hash
                                    -> Table scan on alias8  (rows=1)
            -> Hash
                -> Table scan on alias11  (rows=1)

DROP TABLES t2, t4, t5, t6, t7, t10, t11;
