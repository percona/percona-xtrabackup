--- a/configure.cmake
+++ b/configure.cmake
@@ -987,14 +987,6 @@
 ENDIF()
 
 CHECK_C_SOURCE_COMPILES("
-  int main(int argc, char **argv) 
-  {
-    extern char *__bss_start;
-    return __bss_start ? 1 : 0;
-  }"
-HAVE_BSS_START)
-
-CHECK_C_SOURCE_COMPILES("
     int main()
     {
       extern void __attribute__((weak)) foo(void);
--- a/storage/innobase/CMakeLists.txt
+++ b/storage/innobase/CMakeLists.txt
@@ -44,8 +44,10 @@
 #	SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fno-exceptions")
 ENDIF()
 
-# Enable InnoDB's UNIV_DEBUG and UNIV_SYNC_DEBUG in debug builds
-SET(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -DUNIV_DEBUG -DUNIV_SYNC_DEBUG")
+# In XtraBackup do not enable UNIV_SYNC_DEBUG when UNIV_DEBUG is enabled
+# due to extreme slowness on compact backup testcases
+## Enable InnoDB's UNIV_DEBUG and UNIV_SYNC_DEBUG in debug builds
+#SET(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -DUNIV_DEBUG -DUNIV_SYNC_DEBUG")
 
 # Add -Wconversion if compiling with GCC
 ## As of Mar 15 2011 this flag causes 3573+ warnings. If you are reading this
--- a/storage/innobase/btr/btr0btr.cc
+++ b/storage/innobase/btr/btr0btr.cc
@@ -714,7 +714,7 @@
 /**************************************************************//**
 Gets the root node of a tree and x- or s-latches it.
 @return	root page, x- or s-latched */
-static
+UNIV_INTERN
 buf_block_t*
 btr_root_block_get(
 /*===============*/
@@ -1360,7 +1360,7 @@
 /************************************************************//**
 Returns the child page of a node pointer and x-latches it.
 @return	child page, x-latched */
-static
+UNIV_INTERN
 buf_block_t*
 btr_node_ptr_get_child(
 /*===================*/
--- a/storage/innobase/buf/buf0buf.cc
+++ b/storage/innobase/buf/buf0buf.cc
@@ -53,6 +53,7 @@
 #include "page0zip.h"
 #include "srv0mon.h"
 #include "buf0checksum.h"
+#include "xb0xb.h"
 
 /*
 		IMPLEMENTATION OF THE BUFFER POOL
@@ -568,12 +569,18 @@
 	if (checksum_field1 == 0 && checksum_field2 == 0
 	    && mach_read_from_4(read_buf + FIL_PAGE_LSN) == 0) {
 		/* make sure that the page is really empty */
+#if 0
+		/* Do not make sure that the page is really empty as this check
+		is incompatible with 1st newly-created tablespace pages, which
+		have FIL_PAGE_FIL_FLUSH_LSN != 0, FIL_PAGE_OR_CHKSUM == 0,
+		FIL_PAGE_END_LSN_OLD_CHKSUM == 0 */
 		for (ulint i = 0; i < UNIV_PAGE_SIZE; i++) {
 			if (read_buf[i] != 0) {
 				return(TRUE);
 			}
 		}
 
+#endif
 		return(FALSE);
 	}
 
@@ -998,6 +1005,7 @@
 	block->page.in_flush_list = FALSE;
 	block->page.in_free_list = FALSE;
 	block->page.in_LRU_list = FALSE;
+	block->page.is_compacted = FALSE;
 	block->in_unzip_LRU_list = FALSE;
 #endif /* UNIV_DEBUG */
 #if defined UNIV_AHI_DEBUG || defined UNIV_DEBUG
@@ -4095,6 +4103,13 @@
 			frame = ((buf_block_t*) bpage)->frame;
 		}
 
+		/* Do not validate, recover and apply change buffer entries to
+		bogus pages which replace skipped pages in compact backups. */
+		if (srv_compact_backup && buf_page_is_compacted(frame)) {
+
+			bpage->is_compacted = TRUE;
+		}
+
 		/* If this page is not uninitialized and not in the
 		doublewrite buffer, then the page number and space id
 		should be the same as in block. */
@@ -4212,7 +4227,7 @@
 			recv_recover_page(TRUE, (buf_block_t*) bpage);
 		}
 
-		if (uncompressed && !recv_no_ibuf_operations) {
+		if (uncompressed && !recv_no_ibuf_operations && !bpage->is_compacted) {
 			ibuf_merge_or_delete_for_page(
 				(buf_block_t*) bpage, bpage->space,
 				bpage->offset, buf_page_get_zip_size(bpage),
--- a/storage/innobase/fil/fil0fil.cc
+++ b/storage/innobase/fil/fil0fil.cc
@@ -43,6 +43,8 @@
 #include "dict0dict.h"
 #include "page0page.h"
 #include "page0zip.h"
+#include "pars0pars.h"
+#include "que0que.h"
 #include "trx0sys.h"
 #include "row0mysql.h"
 #ifndef UNIV_HOTBACKUP
@@ -313,17 +315,15 @@
 
 /** The tablespace memory cache. This variable is NULL before the module is
 initialized. */
-static fil_system_t*	fil_system	= NULL;
-
-/** Determine if (i) is a user tablespace id or not. */
-# define fil_is_user_tablespace_id(i) ((i) > srv_undo_tablespaces_open)
+fil_system_t*	fil_system	= NULL;
 
 /** Determine if user has explicitly disabled fsync(). */
 #ifndef __WIN__
-# define fil_buffering_disabled(s)	\
-	((s)->purpose == FIL_TABLESPACE	\
-	 && srv_unix_file_flush_method	\
-	 == SRV_UNIX_O_DIRECT_NO_FSYNC)
+# define fil_buffering_disabled(s)					\
+	(((s)->purpose == FIL_TABLESPACE				\
+	    && srv_unix_file_flush_method == SRV_UNIX_O_DIRECT_NO_FSYNC)\
+	  || ((s)->purpose == FIL_LOG					\
+	    && srv_unix_file_flush_method == SRV_UNIX_ALL_O_DIRECT))
 #else /* __WIN__ */
 # define fil_buffering_disabled(s)	(0)
 #endif /* __WIN__ */
@@ -791,6 +791,7 @@
 				"InnoDB: Error: tablespace id is %lu"
 				" in the data dictionary\n"
 				"InnoDB: but in file %s it is %lu!\n",
+
 				space->id, node->name, space_id);
 
 			ut_error;
@@ -830,8 +831,9 @@
 		}
 
 		if (size_bytes >= 1024 * 1024) {
-			/* Truncate the size to whole megabytes. */
-			size_bytes = ut_2pow_round(size_bytes, 1024 * 1024);
+			/* The size should be exact for after applying
+			.delta */
+			//size_bytes = ut_2pow_round(size_bytes, 1024 * 1024);
 		}
 
 		if (!fsp_flags_is_compressed(flags)) {
@@ -1302,12 +1304,6 @@
 
 		if (!fil_system->space_id_reuse_warned) {
 			fil_system->space_id_reuse_warned = TRUE;
-
-			ib_logf(IB_LOG_LEVEL_WARN,
-				"Allocated tablespace %lu, old maximum "
-				"was %lu",
-				(ulong) id,
-				(ulong) fil_system->max_assigned_id);
 		}
 
 		fil_system->max_assigned_id = id;
@@ -2031,12 +2027,6 @@
 						contain sensible data */
 	ulint*		flags,			/*!< out: tablespace flags */
 	ulint*		space_id,		/*!< out: tablespace ID */
-#ifdef UNIV_LOG_ARCHIVE
-	ulint*		min_arch_log_no,	/*!< out: min of archived
-						log numbers in data files */
-	ulint*		max_arch_log_no,	/*!< out: max of archived
-						log numbers in data files */
-#endif /* UNIV_LOG_ARCHIVE */
 	lsn_t*		min_flushed_lsn,	/*!< out: min of flushed
 						lsn values in data files */
 	lsn_t*		max_flushed_lsn)	/*!< out: max of flushed
@@ -2061,7 +2051,7 @@
 
 	flushed_lsn = mach_read_from_8(page + FIL_PAGE_FILE_FLUSH_LSN);
 
-	if (!one_read_already) {
+	if (!one_read_already && !srv_backup_mode) {
 		check_msg = fil_check_first_page(page);
 	}
 
@@ -2074,10 +2064,6 @@
 	if (!one_read_already) {
 		*min_flushed_lsn = flushed_lsn;
 		*max_flushed_lsn = flushed_lsn;
-#ifdef UNIV_LOG_ARCHIVE
-		*min_arch_log_no = arch_log_no;
-		*max_arch_log_no = arch_log_no;
-#endif /* UNIV_LOG_ARCHIVE */
 		return(NULL);
 	}
 
@@ -2087,14 +2073,6 @@
 	if (*max_flushed_lsn < flushed_lsn) {
 		*max_flushed_lsn = flushed_lsn;
 	}
-#ifdef UNIV_LOG_ARCHIVE
-	if (*min_arch_log_no > arch_log_no) {
-		*min_arch_log_no = arch_log_no;
-	}
-	if (*max_arch_log_no < arch_log_no) {
-		*max_arch_log_no = arch_log_no;
-	}
-#endif /* UNIV_LOG_ARCHIVE */
 
 	return(NULL);
 }
@@ -2195,7 +2173,7 @@
 	mem_free(path);
 }
 
-#ifndef UNIV_HOTBACKUP
+#if 0
 /********************************************************//**
 Writes a log record about an .ibd file create/rename/delete. */
 static
@@ -2423,7 +2401,7 @@
 				    space_id, name, path, flags,
 				    DICT_TF2_USE_TABLESPACE,
 				    FIL_IBD_FILE_INITIAL_SIZE) != DB_SUCCESS) {
-				ut_error;
+				//ut_error;
 			}
 		}
 
@@ -2782,7 +2760,7 @@
 	}
 
 	if (err == DB_SUCCESS) {
-#ifndef UNIV_HOTBACKUP
+#if 0
 		/* Write a log record about the deletion of the .ibd
 		file, so that ibbackup can replay it in the
 		--apply-log phase. We use a dummy mtr and the familiar
@@ -3137,7 +3115,7 @@
 
 	mutex_exit(&fil_system->mutex);
 
-#ifndef UNIV_HOTBACKUP
+#if 0
 	if (success && !recv_recovery_on) {
 		mtr_t		mtr;
 
@@ -3368,7 +3346,21 @@
 	ibool		success;
 	/* TRUE if a table is created with CREATE TEMPORARY TABLE */
 	bool		is_temp = !!(flags2 & DICT_TF2_TEMPORARY);
+
+	/* For XtraBackup recovery we force remote tablespaces to be local,
+	i.e. never execute the code path corresponding to has_data_dir == true.
+	We don't create .isl files either, because we rely on innobackupex to
+	copy them under a global lock, and use them to copy remote tablespaces
+	to their proper locations on --copy-back.
+
+	See also MySQL bug #72022: dir_path is always NULL for remote
+	tablespaces when a MLOG_FILE_CREATE* log record is replayed (the remote
+	directory is not available from MLOG_FILE_CREATE*). */
+#if 0
 	bool		has_data_dir = FSP_FLAGS_HAS_DATA_DIR(flags);
+#else
+	bool		has_data_dir = false;
+#endif
 
 	ut_a(space_id > 0);
 	ut_ad(!srv_read_only_mode);
@@ -3521,7 +3513,7 @@
 		goto error_exit_1;
 	}
 
-#ifndef UNIV_HOTBACKUP
+#if 0
 	{
 		mtr_t		mtr;
 		ulint		mlog_file_flag = 0;
@@ -3599,6 +3591,97 @@
 		(ulong) expected_id, (ulong) expected_flags);
 }
 
+static
+void
+fil_remove_invalid_table_from_data_dict(const char *name)
+{
+	trx_t*		trx;
+	pars_info_t*	info = NULL;
+
+	trx = trx_allocate_for_mysql();
+	trx_start_for_ddl(trx, TRX_DICT_OP_TABLE);
+
+	ut_ad(mutex_own(&dict_sys->mutex));
+
+	trx->op_info = "removing invalid table from data dictionary";
+
+	info = pars_info_create();
+
+	pars_info_add_str_literal(info, "table_name", name);
+
+	que_eval_sql(info,
+		     "PROCEDURE DROP_TABLE_PROC () IS\n"
+		     "sys_foreign_id CHAR;\n"
+		     "table_id CHAR;\n"
+		     "index_id CHAR;\n"
+		     "foreign_id CHAR;\n"
+		     "found INT;\n"
+		     "BEGIN\n"
+		     "SELECT ID INTO table_id\n"
+		     "FROM SYS_TABLES\n"
+		     "WHERE NAME = :table_name\n"
+		     "LOCK IN SHARE MODE;\n"
+		     "IF (SQL % NOTFOUND) THEN\n"
+		     "       RETURN;\n"
+		     "END IF;\n"
+		     "found := 1;\n"
+		     "SELECT ID INTO sys_foreign_id\n"
+		     "FROM SYS_TABLES\n"
+		     "WHERE NAME = 'SYS_FOREIGN'\n"
+		     "LOCK IN SHARE MODE;\n"
+		     "IF (SQL % NOTFOUND) THEN\n"
+		     "       found := 0;\n"
+		     "END IF;\n"
+		     "IF (:table_name = 'SYS_FOREIGN') THEN\n"
+		     "       found := 0;\n"
+		     "END IF;\n"
+		     "IF (:table_name = 'SYS_FOREIGN_COLS') THEN\n"
+		     "       found := 0;\n"
+		     "END IF;\n"
+		     "WHILE found = 1 LOOP\n"
+		     "       SELECT ID INTO foreign_id\n"
+		     "       FROM SYS_FOREIGN\n"
+		     "       WHERE FOR_NAME = :table_name\n"
+		     "               AND TO_BINARY(FOR_NAME)\n"
+		     "                 = TO_BINARY(:table_name)\n"
+		     "               LOCK IN SHARE MODE;\n"
+		     "       IF (SQL % NOTFOUND) THEN\n"
+		     "               found := 0;\n"
+		     "       ELSE\n"
+		     "               DELETE FROM SYS_FOREIGN_COLS\n"
+		     "               WHERE ID = foreign_id;\n"
+		     "               DELETE FROM SYS_FOREIGN\n"
+		     "               WHERE ID = foreign_id;\n"
+		     "       END IF;\n"
+		     "END LOOP;\n"
+		     "found := 1;\n"
+		     "WHILE found = 1 LOOP\n"
+		     "       SELECT ID INTO index_id\n"
+		     "       FROM SYS_INDEXES\n"
+		     "       WHERE TABLE_ID = table_id\n"
+		     "       LOCK IN SHARE MODE;\n"
+		     "       IF (SQL % NOTFOUND) THEN\n"
+		     "               found := 0;\n"
+		     "       ELSE\n"
+		     "               DELETE FROM SYS_FIELDS\n"
+		     "               WHERE INDEX_ID = index_id;\n"
+		     "               DELETE FROM SYS_INDEXES\n"
+		     "               WHERE ID = index_id\n"
+		     "               AND TABLE_ID = table_id;\n"
+		     "       END IF;\n"
+		     "END LOOP;\n"
+		     "DELETE FROM SYS_COLUMNS\n"
+		     "WHERE TABLE_ID = table_id;\n"
+		     "DELETE FROM SYS_TABLES\n"
+		     "WHERE ID = table_id;\n"
+		     "END;\n"
+		     , FALSE, trx);
+
+	trx_commit_for_mysql(trx);
+
+	trx_free_for_mysql(trx);
+}
+
 /********************************************************************//**
 Tries to open a single-table tablespace and optionally checks that the
 space id in it is correct. If this does not succeed, print an error message
@@ -3664,6 +3747,9 @@
 	in the default location. If it is remote, it should not be here. */
 	def.filepath = fil_make_ibd_name(tablename, false);
 
+	/* We skip SYS_DATAFILES validation and remote tablespaces discovery for
+	XtraBackup, as all tablespaces are local for XtraBackup recovery. */
+#if 0
 	/* The path_in was read from SYS_DATAFILES. */
 	if (path_in) {
 		if (strcmp(def.filepath, path_in)) {
@@ -3711,6 +3797,7 @@
 			tablespaces_found++;
 		}
 	}
+#endif
 
 	/* Always look for a file at the default location. */
 	ut_a(def.filepath);
@@ -3732,9 +3819,6 @@
 	if (def.success) {
 		def.check_msg = fil_read_first_page(
 			def.file, FALSE, &def.flags, &def.id,
-#ifdef UNIV_LOG_ARCHIVE
-			&space_arch_log_no, &space_arch_log_no,
-#endif /* UNIV_LOG_ARCHIVE */
 			&def.lsn, &def.lsn);
 		def.valid = !def.check_msg;
 
@@ -3757,9 +3841,6 @@
 	if (remote.success) {
 		remote.check_msg = fil_read_first_page(
 			remote.file, FALSE, &remote.flags, &remote.id,
-#ifdef UNIV_LOG_ARCHIVE
-			&remote.arch_log_no, &remote.arch_log_no,
-#endif /* UNIV_LOG_ARCHIVE */
 			&remote.lsn, &remote.lsn);
 		remote.valid = !remote.check_msg;
 
@@ -3783,9 +3864,6 @@
 	if (dict.success) {
 		dict.check_msg = fil_read_first_page(
 			dict.file, FALSE, &dict.flags, &dict.id,
-#ifdef UNIV_LOG_ARCHIVE
-			&dict.arch_log_no, &dict.arch_log_no,
-#endif /* UNIV_LOG_ARCHIVE */
 			&dict.lsn, &dict.lsn);
 		dict.valid = !dict.check_msg;
 
@@ -3810,11 +3888,15 @@
 		/* The following call prints an error message */
 		os_file_get_last_error(true);
 
-		ib_logf(IB_LOG_LEVEL_ERROR,
+		ib_logf(IB_LOG_LEVEL_WARN,
 			"Could not find a valid tablespace file for '%s'. "
 			"See " REFMAN "innodb-troubleshooting-datadict.html "
 			"for how to resolve the issue.",
 			tablename);
+		ib_logf(IB_LOG_LEVEL_WARN,
+			"It will be removed from the data dictionary.");
+
+		fil_remove_invalid_table_from_data_dict(tablename);
 
 		err = DB_CORRUPTION;
 
@@ -4187,9 +4269,6 @@
 	fsp->success = TRUE;
 	if (const char* check_msg = fil_read_first_page(
 		    fsp->file, FALSE, &fsp->flags, &fsp->id,
-#ifdef UNIV_LOG_ARCHIVE
-		    &fsp->arch_log_no, &fsp->arch_log_no,
-#endif /* UNIV_LOG_ARCHIVE */
 		    &fsp->lsn, &fsp->lsn)) {
 		ib_logf(IB_LOG_LEVEL_ERROR,
 			"%s in tablespace %s (table %s)",
@@ -4266,6 +4345,9 @@
 #ifdef UNIV_HOTBACKUP
 	fil_space_t*	space;
 #endif
+	fsp_open_info*	fsp;
+	ulong		minimum_size;
+	ibool		file_space_create_success;
 
 	memset(&def, 0, sizeof(def));
 	memset(&remote, 0, sizeof(remote));
@@ -4310,6 +4392,9 @@
 # endif /* !UNIV_HOTBACKUP */
 #endif
 
+	/* Ignore .isl files on XtraBackup recovery. All tablespaces must be
+	local. */
+	if (srv_backup_mode) {
 	/* Check for a link file which locates a remote tablespace. */
 	remote.success = fil_open_linked_file(
 		tablename, &remote.filepath, &remote.file);
@@ -4320,8 +4405,20 @@
 		if (!remote.success) {
 			os_file_close(remote.file);
 			mem_free(remote.filepath);
+
+			if (srv_backup_mode) {
+
+				/* Ignore files that have uninitialized space
+				IDs on the backup stage. This means that a
+				tablespace has just been created and we will
+				replay the corresponding log records on
+				prepare. */
+
+				goto func_exit_after_close;
+			}
 		}
 	}
+	}
 
 
 	/* Try to open the tablespace in the datadir. */
@@ -4334,6 +4431,17 @@
 		fil_validate_single_table_tablespace(tablename, &def);
 		if (!def.success) {
 			os_file_close(def.file);
+
+			if (srv_backup_mode) {
+
+				/* Ignore files that have uninitialized space
+				IDs on the backup stage. This means that a
+				tablespace has just been created and we will
+				replay the corresponding log records on
+				prepare. */
+
+				goto func_exit_after_close;
+			}
 		}
 	}
 
@@ -4418,7 +4526,7 @@
 	/* At this point, only one tablespace is open */
 	ut_a(def.success == !remote.success);
 
-	fsp_open_info*	fsp = def.success ? &def : &remote;
+	fsp = def.success ? &def : &remote;
 
 	/* Get and test the file size. */
 	size = os_file_get_size(fsp->file);
@@ -4437,9 +4545,9 @@
 
 	/* Every .ibd file is created >= 4 pages in size. Smaller files
 	cannot be ok. */
-	ulong minimum_size = FIL_IBD_FILE_INITIAL_SIZE * UNIV_PAGE_SIZE;
+	minimum_size = FIL_IBD_FILE_INITIAL_SIZE * UNIV_PAGE_SIZE;
 	if (size < minimum_size) {
-#ifndef UNIV_HOTBACKUP
+#if 0
 		ib_logf(IB_LOG_LEVEL_ERROR,
 			"The size of single-table tablespace file %s "
 			"is only " UINT64PF ", should be at least %lu!",
@@ -4520,7 +4628,7 @@
 	}
 	mutex_exit(&fil_system->mutex);
 #endif /* UNIV_HOTBACKUP */
-	ibool file_space_create_success = fil_space_create(
+	file_space_create_success = fil_space_create(
 		tablename, fsp->id, fsp->flags, FIL_TABLESPACE);
 
 	if (!file_space_create_success) {
@@ -4547,13 +4655,55 @@
 	}
 
 func_exit:
-	os_file_close(fsp->file);
+	/* We reuse file handles on the backup stage in XtraBackup to avoid
+	inconsistencies between the file name and the actual tablespace contents
+	if a DDL occurs between a fil_load_single_table_tablespaces() call and
+	the actual copy operation. */
+	if (srv_backup_mode && !srv_close_files) {
+
+		fil_node_t*	node;
+		fil_space_t*	space;
+
+		mutex_enter(&fil_system->mutex);
+
+		space = fil_space_get_by_id(fsp->id);
+
+		if (space) {
+			node = UT_LIST_GET_LAST(space->chain);
+
+			/* The handle will be closed by xtrabackup in
+			xtrabackup_copy_datafile(). We set node->open to TRUE to
+			make sure no one calls fil_node_open_file()
+			(i.e. attempts to reopen the tablespace by name) during
+			the backup stage. */
+
+			node->open = TRUE;
+			node->handle = fsp->file;
+
+			/* The following is copied from fil_node_open_file() to
+			pass fil_system validaty checks. We cannot use
+			fil_node_open_file() directly, as that would re-open the
+			file by name and create another file handle. */
+
+			fil_system->n_open++;
+			fil_n_file_opened++;
+
+			if (fil_space_belongs_in_lru(space)) {
+
+				/* Put the node to the LRU list */
+				UT_LIST_ADD_FIRST(LRU, fil_system->LRU, node);
+			}
+		}
+
+		mutex_exit(&fil_system->mutex);
+	} else {
+
+		os_file_close(fsp->file);
+	}
 
-#ifdef UNIV_HOTBACKUP
 func_exit_after_close:
-#else
 	ut_ad(!mutex_own(&fil_system->mutex));
-#endif
+
 	mem_free(tablename);
 	if (remote.success) {
 		mem_free(remote.filepath);
@@ -4567,7 +4717,7 @@
 idea is to read as much good data as we can and jump over bad data.
 @return 0 if ok, -1 if error even after the retries, 1 if at the end
 of the directory */
-static
+UNIV_INTERN
 int
 fil_file_readdir_next_file(
 /*=======================*/
@@ -4607,7 +4757,7 @@
 @return	DB_SUCCESS or error number */
 UNIV_INTERN
 dberr_t
-fil_load_single_table_tablespaces(void)
+fil_load_single_table_tablespaces(ibool (*pred)(const char*, const char*))
 /*===================================*/
 {
 	int		ret;
@@ -4663,7 +4813,9 @@
 			    "%s/%s", fil_path_to_mysql_datadir, dbinfo.name);
 		srv_normalize_path_for_win(dbpath);
 
-		dbdir = os_file_opendir(dbpath, FALSE);
+		/* We want wrong directory permissions to be a fatal error for
+		XtraBackup. */
+		dbdir = os_file_opendir(dbpath, TRUE);
 
 		if (dbdir != NULL) {
 
@@ -4684,9 +4836,15 @@
 				    && (0 == strcmp(fileinfo.name
 						   + strlen(fileinfo.name) - 4,
 						   ".ibd")
-					|| 0 == strcmp(fileinfo.name
+					/* Ignore .isl files on XtraBackup
+					recovery, all tablespaces must be
+					local. */
+					|| (srv_backup_mode &&
+					    0 == strcmp(fileinfo.name
 						   + strlen(fileinfo.name) - 4,
-						   ".isl"))) {
+							".isl")))
+				    && (!pred ||
+					pred(dbinfo.name, fileinfo.name))) {
 					/* The name ends in .ibd or .isl;
 					try opening the file */
 					fil_load_single_table_tablespace(
@@ -4842,6 +5000,7 @@
 {
 	fil_space_t*	fnamespace;
 	fil_space_t*	space;
+	ibool		remove_from_data_dict = FALSE;
 
 	ut_ad(fil_system);
 
@@ -4919,6 +5078,10 @@
 		if (fnamespace == NULL) {
 			if (print_error_if_does_not_exist) {
 				fil_report_missing_tablespace(name, id);
+				ib_logf(IB_LOG_LEVEL_WARN,
+					"It will be removed from "
+					"the data dictionary.");
+				remove_from_data_dict = TRUE;
 			}
 		} else {
 			ut_print_timestamp(stderr);
@@ -4942,6 +5105,10 @@
 
 		mutex_exit(&fil_system->mutex);
 
+		if (remove_from_data_dict) {
+			fil_remove_invalid_table_from_data_dict(name);
+		}
+
 		return(FALSE);
 	}
 
@@ -5575,6 +5742,16 @@
 
 	ut_ad(mode != OS_AIO_IBUF || space->purpose == FIL_TABLESPACE);
 
+	if (space->size > 0 && space->size <= block_offset) {
+		ulint	actual_size;
+
+		mutex_exit(&fil_system->mutex);
+		fil_extend_space_to_desired_size(&actual_size, space->id,
+						 block_offset + 1);
+		mutex_enter(&fil_system->mutex);
+		/* should retry? but it may safe for xtrabackup for now. */
+	}
+
 	node = UT_LIST_GET_FIRST(space->chain);
 
 	for (;;) {
@@ -6502,6 +6679,7 @@
 	return(err);
 }
 
+#if 0
 /****************************************************************//**
 Generate redo logs for swapping two .ibd files */
 UNIV_INTERN
@@ -6528,3 +6706,4 @@
 				 0, 0, new_name, old_name, mtr);
 	}
 }
+#endif
--- a/storage/innobase/handler/ha_innodb.cc
+++ b/storage/innobase/handler/ha_innodb.cc
@@ -207,7 +207,8 @@
 	NULL
 };
 
-/** Possible values for system variable "innodb_checksum_algorithm". */
+/** Possible values for system variables "innodb_checksum_algorithm" and
+"innodb_log_checksum_algorithm". */
 static const char* innodb_checksum_algorithm_names[] = {
 	"crc32",
 	"strict_crc32",
@@ -218,8 +219,8 @@
 	NullS
 };
 
-/** Used to define an enumerate type of the system variable
-innodb_checksum_algorithm. */
+/** Used to define an enumerate type of the system variables
+innodb_checksum_algorithm and innodb_log_checksum_algorithm. */
 static TYPELIB innodb_checksum_algorithm_typelib = {
 	array_elements(innodb_checksum_algorithm_names) - 1,
 	"innodb_checksum_algorithm_typelib",
@@ -1587,7 +1588,7 @@
 		ut_ad(*mbminlen < DATA_MBMAX);
 		ut_ad(*mbmaxlen < DATA_MBMAX);
 	} else {
-		THD*	thd = current_thd;
+		THD*	thd = NULL;
 
 		if (thd && thd_sql_command(thd) == SQLCOM_DROP_TABLE) {
 
@@ -2132,6 +2133,62 @@
 	return(trx->state != TRX_STATE_NOT_STARTED);
 }
 
+/****************************************************************//**
+Update log_checksum_algorithm_ptr with a pointer to the function corresponding
+to a given checksum algorithm. */
+UNIV_INTERN
+void
+innodb_log_checksum_func_update(
+/*============================*/
+	ulint	algorithm)	/*!< in: algorithm */
+{
+	switch (algorithm) {
+	case SRV_CHECKSUM_ALGORITHM_STRICT_INNODB:
+	case SRV_CHECKSUM_ALGORITHM_INNODB:
+		log_checksum_algorithm_ptr=log_block_calc_checksum_innodb;
+		break;
+	case SRV_CHECKSUM_ALGORITHM_STRICT_CRC32:
+	case SRV_CHECKSUM_ALGORITHM_CRC32:
+		log_checksum_algorithm_ptr=log_block_calc_checksum_crc32;
+		break;
+	case SRV_CHECKSUM_ALGORITHM_STRICT_NONE:
+	case SRV_CHECKSUM_ALGORITHM_NONE:
+		log_checksum_algorithm_ptr=log_block_calc_checksum_none;
+		break;
+	default:
+		ut_a(0);
+	}
+}
+
+/****************************************************************//**
+On update hook for the innodb_log_checksum_algorithm variable. */
+static
+void
+innodb_log_checksum_algorithm_update(
+/*=================================*/
+	THD*				thd,	/*!< in: thread handle */
+	struct st_mysql_sys_var*	var,	/*!< in: pointer to
+						system variable */
+	void*				var_ptr,/*!< out: where the
+						formal string goes */
+	const void*			save)	/*!< in: immediate result
+						from check function */
+{
+	srv_checksum_algorithm_t	algorithm;
+
+	algorithm = (srv_checksum_algorithm_t)
+		(*static_cast<const ulong*>(save));
+
+	/* Make sure we are the only log user */
+	mutex_enter(&log_sys->mutex);
+
+	innodb_log_checksum_func_update(algorithm);
+
+	srv_log_checksum_algorithm = algorithm;
+
+	mutex_exit(&log_sys->mutex);
+}
+
 /*********************************************************************//**
 Copy table flags from MySQL's HA_CREATE_INFO into an InnoDB table object.
 Those flags are stored in .frm file and end up in the MySQL table object,
@@ -2497,40 +2554,19 @@
 	ulint		buflen,	/*!< in: length of buf, in bytes */
 	const char*	id,	/*!< in: identifier to convert */
 	ulint		idlen,	/*!< in: length of id, in bytes */
-	THD*		thd,	/*!< in: MySQL connection thread, or NULL */
-	ibool		file_id)/*!< in: TRUE=id is a table or database name;
+	THD*		thd __attribute__((unused)),
+				/*!< in: MySQL connection thread, or NULL */
+	ibool		file_id __attribute__((unused)))
+				/*!< in: TRUE=id is a table or database name;
 				FALSE=id is an UTF-8 string */
 {
 	const char*	s	= id;
 	int		q;
 
-	if (file_id) {
-
-		char nz[MAX_TABLE_NAME_LEN + 1];
-		char nz2[MAX_TABLE_NAME_LEN + 1];
-
-		/* Decode the table name.  The MySQL function expects
-		a NUL-terminated string.  The input and output strings
-		buffers must not be shared. */
-		ut_a(idlen <= MAX_TABLE_NAME_LEN);
-		memcpy(nz, id, idlen);
-		nz[idlen] = 0;
-
-		s = nz2;
-		idlen = explain_filename(thd, nz, nz2, sizeof nz2,
-					 EXPLAIN_PARTITIONS_AS_COMMENT);
-		goto no_quote;
-	}
-
 	/* See if the identifier needs to be quoted. */
-	if (UNIV_UNLIKELY(!thd)) {
-		q = '"';
-	} else {
-		q = get_quote_char_for_identifier(thd, s, (int) idlen);
-	}
+	q = '"';
 
 	if (q == EOF) {
-no_quote:
 		if (UNIV_UNLIKELY(idlen > buflen)) {
 			idlen = buflen;
 		}
@@ -2921,12 +2957,9 @@
 	}
 
 #ifdef UNIV_LOG_ARCHIVE
-	/* Since innodb_log_arch_dir has no relevance under MySQL,
-	starting from 4.0.6 we always set it the same as
-	innodb_log_group_home_dir: */
-
-	innobase_log_arch_dir = innobase_log_group_home_dir;
-
+	if (!innobase_log_arch_dir) {
+		innobase_log_arch_dir = srv_log_group_home_dir;
+	}
 	srv_arch_dir = innobase_log_arch_dir;
 #endif /* UNIG_LOG_ARCHIVE */
 
@@ -3168,6 +3201,8 @@
 		srv_checksum_algorithm = SRV_CHECKSUM_ALGORITHM_NONE;
 	}
 
+	innodb_log_checksum_func_update(srv_log_checksum_algorithm);
+
 #ifdef HAVE_LARGE_PAGES
 	if ((os_use_large_pages = (ibool) my_use_large_pages)) {
 		os_large_page_size = (ulint) opt_large_page_size;
@@ -15641,6 +15676,33 @@
   NULL, NULL, SRV_CHECKSUM_ALGORITHM_INNODB,
   &innodb_checksum_algorithm_typelib);
 
+
+static MYSQL_SYSVAR_ENUM(log_checksum_algorithm, srv_log_checksum_algorithm,
+  PLUGIN_VAR_RQCMDARG,
+  "The algorithm InnoDB uses for log block checksums. Possible values are "
+  "CRC32 (hardware accelerated if the CPU supports it) "
+    "write crc32, allow any of the other checksums to match when reading; "
+  "STRICT_CRC32 "
+    "write crc32, do not allow other algorithms to match when reading; "
+  "INNODB "
+    "write a software calculated checksum, allow any other checksums "
+    "to match when reading; "
+  "STRICT_INNODB "
+    "write a software calculated checksum, do not allow other algorithms "
+    "to match when reading; "
+  "NONE "
+    "write a constant magic number, do not do any checksum verification "
+    "when reading (same as innodb_checksums=OFF); "
+  "STRICT_NONE "
+    "write a constant magic number, do not allow values other than that "
+    "magic number when reading; "
+  "Logs created when this option is set to crc32/strict_crc32/none/strict_none "
+  "will not be readable by any MySQL version or Percona Server versions that do"
+  "not support this feature",
+  NULL, innodb_log_checksum_algorithm_update, SRV_CHECKSUM_ALGORITHM_INNODB,
+  &innodb_checksum_algorithm_typelib);
+
+
 static MYSQL_SYSVAR_BOOL(checksums, innobase_use_checksums,
   PLUGIN_VAR_NOCMDARG | PLUGIN_VAR_READONLY,
   "DEPRECATED. Use innodb_checksum_algorithm=NONE instead of setting "
@@ -16447,6 +16509,7 @@
   MYSQL_SYSVAR(lru_scan_depth),
   MYSQL_SYSVAR(flush_neighbors),
   MYSQL_SYSVAR(checksum_algorithm),
+  MYSQL_SYSVAR(log_checksum_algorithm),
   MYSQL_SYSVAR(checksums),
   MYSQL_SYSVAR(commit_concurrency),
   MYSQL_SYSVAR(concurrency_tickets),
@@ -17034,47 +17097,24 @@
 void
 ib_logf(
 /*====*/
-	ib_log_level_t	level,		/*!< in: warning level */
+	ib_log_level_t	level __attribute__((unused)),
+					/*!< in: warning level */
 	const char*	format,		/*!< printf format */
 	...)				/*!< Args */
 {
-	char*		str;
 	va_list         args;
 
 	va_start(args, format);
 
-#ifdef __WIN__
-	int		size = _vscprintf(format, args) + 1;
-	str = static_cast<char*>(malloc(size));
-	str[size - 1] = 0x0;
-	vsnprintf(str, size, format, args);
-#elif HAVE_VASPRINTF
-	int	ret;
-	ret = vasprintf(&str, format, args);
-	ut_a(ret != -1);
-#else
-	/* Use a fixed length string. */
-	str = static_cast<char*>(malloc(BUFSIZ));
-	my_vsnprintf(str, BUFSIZ, format, args);
-#endif /* __WIN__ */
+	/* Don't use server logger for XtraBackup, just print to stderr. */
 
-	switch(level) {
-	case IB_LOG_LEVEL_INFO:
-		sql_print_information("InnoDB: %s", str);
-		break;
-	case IB_LOG_LEVEL_WARN:
-		sql_print_warning("InnoDB: %s", str);
-		break;
-	case IB_LOG_LEVEL_ERROR:
-		sql_print_error("InnoDB: %s", str);
-		break;
-	case IB_LOG_LEVEL_FATAL:
-		sql_print_error("InnoDB: %s", str);
-		break;
-	}
+	fprintf(stderr, "InnoDB: ");
+
+	vfprintf(stderr, format, args);
 
 	va_end(args);
-	free(str);
+
+	fputc('\n', stderr);
 
 	if (level == IB_LOG_LEVEL_FATAL) {
 		ut_error;
--- a/storage/innobase/handler/handler0alter.cc
+++ b/storage/innobase/handler/handler0alter.cc
@@ -5505,6 +5505,7 @@
 				= static_cast<ha_innobase_inplace_ctx*>(*pctx);
 
 			DBUG_ASSERT(ctx->need_rebuild());
+#if 0
 			/* Generate the redo log for the file
 			operations that will be performed in
 			commit_cache_rebuild(). */
@@ -5513,6 +5514,7 @@
 					   ctx->new_table->space,
 					   ctx->new_table->name,
 					   ctx->tmp_name, &mtr);
+#endif
 			DBUG_INJECT_CRASH("ib_commit_inplace_crash",
 					  crash_inject_count++);
 		}
--- a/storage/innobase/include/buf0buf.h
+++ b/storage/innobase/include/buf0buf.h
@@ -1610,6 +1610,8 @@
 					or buf_block_t::mutex. */
 # endif /* UNIV_DEBUG_FILE_ACCESSES || UNIV_DEBUG */
 #endif /* !UNIV_HOTBACKUP */
+	ibool		is_compacted;	/*!< TRUE if page was skipped in
+					compact backups */
 };
 
 /** The buffer control block structure */
--- a/storage/innobase/include/fil0fil.h
+++ b/storage/innobase/include/fil0fil.h
@@ -165,6 +165,9 @@
 #define FIL_LOG			502	/*!< redo log */
 /* @} */
 
+/** Determine if (i) is a user tablespace id or not. */
+#define fil_is_user_tablespace_id(i) ((i) > srv_undo_tablespaces_open)
+
 /** The number of fsyncs done to the log */
 extern ulint	fil_n_log_flushes;
 
@@ -185,9 +188,6 @@
 	lsn_t		lsn;		/*!< Flushed LSN from header page */
 	ulint		id;		/*!< Space ID */
 	ulint		flags;		/*!< Tablespace flags */
-#ifdef UNIV_LOG_ARCHIVE
-	ulint		arch_log_no;	/*!< latest archived log file number */
-#endif /* UNIV_LOG_ARCHIVE */
 };
 
 #ifndef UNIV_HOTBACKUP
@@ -389,12 +389,6 @@
 						contain sensible data */
 	ulint*		flags,			/*!< out: tablespace flags */
 	ulint*		space_id,		/*!< out: tablespace ID */
-#ifdef UNIV_LOG_ARCHIVE
-	ulint*		min_arch_log_no,	/*!< out: min of archived
-						log numbers in data files */
-	ulint*		max_arch_log_no,	/*!< out: max of archived
-						log numbers in data files */
-#endif /* UNIV_LOG_ARCHIVE */
 	lsn_t*		min_flushed_lsn,	/*!< out: min of flushed
 						lsn values in data files */
 	lsn_t*		max_flushed_lsn)	/*!< out: max of flushed
@@ -627,7 +621,7 @@
 @return	DB_SUCCESS or error number */
 UNIV_INTERN
 dberr_t
-fil_load_single_table_tablespaces(void);
+fil_load_single_table_tablespaces(ibool (*pred)(const char*, const char*));
 /*===================================*/
 /*******************************************************************//**
 Returns TRUE if a single-table tablespace does not exist in the memory cache,
--- a/storage/innobase/include/log0log.h
+++ b/storage/innobase/include/log0log.h
@@ -62,6 +62,15 @@
 # define log_do_write TRUE
 #endif /* UNIV_DEBUG */
 
+/** Magic value to use instead of log checksums when they are disabled */
+#define LOG_NO_CHECKSUM_MAGIC 0xDEADBEEFUL
+
+typedef ulint (*log_checksum_func_t)(const byte* log_block);
+
+/** Pointer to the log checksum calculation function. Protected with
+log_sys->mutex. */
+extern log_checksum_func_t log_checksum_algorithm_ptr;
+
 /** Wait modes for log_write_up_to @{ */
 #define LOG_NO_WAIT		91
 #define LOG_WAIT_ONE_GROUP	92
@@ -70,6 +79,10 @@
 /** Maximum number of log groups in log_group_t::checkpoint_buf */
 #define LOG_MAX_N_GROUPS	32
 
+#define IB_ARCHIVED_LOGS_PREFIX		"ib_log_archive_"
+#define IB_ARCHIVED_LOGS_PREFIX_LEN	(sizeof(IB_ARCHIVED_LOGS_PREFIX) - 1)
+#define IB_ARCHIVED_LOGS_SERIAL_LEN	20
+
 /*******************************************************************//**
 Calculates where in log files we find a specified lsn.
 @return	log file number */
@@ -340,8 +353,18 @@
 log_archived_file_name_gen(
 /*=======================*/
 	char*	buf,	/*!< in: buffer where to write */
+	ulint	buf_len,/*!< in: buffer length */
 	ulint	id,	/*!< in: group id */
-	ulint	file_no);/*!< in: file number */
+	lsn_t	file_no);/*!< in: file number */
+
+UNIV_INTERN
+void
+log_archived_get_offset(
+/*====================*/
+	log_group_t*	group,		/*!< in: log group */
+	lsn_t		file_no,	/*!< in: archive log file number */
+	lsn_t		archived_lsn,	/*!< in: last archived LSN */
+	lsn_t*		offset);	/*!< out: offset within archived file */
 #else /* !UNIV_HOTBACKUP */
 /******************************************************//**
 Writes info to a buffer of a log group when log files are created in
@@ -681,6 +704,9 @@
 					when mysqld is first time started
 					on the restored database, it can
 					print helpful info for the user */
+#define LOG_FILE_OS_FILE_LOG_BLOCK_SIZE 64
+					/* extend to record log_block_size
+					of XtraDB. 0 means default 512 */
 #define	LOG_FILE_ARCH_COMPLETED	OS_FILE_LOG_BLOCK_SIZE
 					/* this 4-byte field is TRUE when
 					the writing of an archived log file
@@ -736,19 +762,19 @@
 	ulint		archive_space_id;/*!< file space which
 					implements the log group
 					archive */
-	ulint		archived_file_no;/*!< file number corresponding to
+	lsn_t		archived_file_no;/*!< file number corresponding to
 					log_sys->archived_lsn */
-	ulint		archived_offset;/*!< file offset corresponding to
+	lsn_t		archived_offset;/*!< file offset corresponding to
 					log_sys->archived_lsn, 0 if we have
 					not yet written to the archive file
 					number archived_file_no */
-	ulint		next_archived_file_no;/*!< during an archive write,
+	lsn_t		next_archived_file_no;/*!< during an archive write,
 					until the write is completed, we
 					store the next value for
 					archived_file_no here: the write
 					completion function then sets the new
 					value to ..._file_no */
-	ulint		next_archived_offset; /*!< like the preceding field */
+	lsn_t		next_archived_offset; /*!< like the preceding field */
 #endif /* UNIV_LOG_ARCHIVE */
 	/*-----------------------------*/
 	lsn_t		scanned_lsn;	/*!< used only in recovery: recovery scan
--- a/storage/innobase/include/log0log.ic
+++ b/storage/innobase/include/log0log.ic
@@ -27,6 +27,8 @@
 #include "mach0data.h"
 #include "mtr0mtr.h"
 #include "srv0mon.h"
+#include "srv0srv.h"
+#include "ut0crc32.h"
 
 #ifdef UNIV_LOG_DEBUG
 /******************************************************//**
@@ -199,7 +201,7 @@
 }
 
 /************************************************************//**
-Calculates the checksum for a log block.
+Calculates the checksum for a log block using the current algorithm.
 @return	checksum */
 UNIV_INLINE
 ulint
@@ -207,6 +209,17 @@
 /*====================*/
 	const byte*	block)	/*!< in: log block */
 {
+	return(log_checksum_algorithm_ptr(block));
+}
+/************************************************************//**
+Calculates the checksum for a log block using the default InnoDB algorithm.
+@return	checksum */
+UNIV_INLINE
+ulint
+log_block_calc_checksum_innodb(
+/*===========================*/
+	const byte*	block)	/*!< in: log block */
+{
 	ulint	sum;
 	ulint	sh;
 	ulint	i;
@@ -229,6 +242,30 @@
 }
 
 /************************************************************//**
+Calculates the checksum for a log block using the CRC32 algorithm.
+@return	checksum */
+UNIV_INLINE
+ulint
+log_block_calc_checksum_crc32(
+/*==========================*/
+	const byte*	block)	/*!< in: log block */
+{
+	return(ut_crc32(block, OS_FILE_LOG_BLOCK_SIZE - LOG_BLOCK_TRL_SIZE));
+}
+
+/************************************************************//**
+Calculates the checksum for a log block using the "no-op" algorithm.
+@return	checksum */
+UNIV_INLINE
+ulint
+log_block_calc_checksum_none(
+/*=========================*/
+	const byte*	block)	/*!< in: log block */
+{
+	return(LOG_NO_CHECKSUM_MAGIC);
+}
+
+/************************************************************//**
 Gets a log block checksum field value.
 @return	checksum */
 UNIV_INLINE
--- a/storage/innobase/include/log0recv.h
+++ b/storage/innobase/include/log0recv.h
@@ -298,18 +298,13 @@
 Recovers from archived log files, and also from log files, if they exist.
 @return	error code or DB_SUCCESS */
 UNIV_INTERN
-ulint
+dberr_t
 recv_recovery_from_archive_start(
 /*=============================*/
 	lsn_t		min_flushed_lsn,/*!< in: min flushed lsn field from the
 					data files */
-	lsn_t		limit_lsn,	/*!< in: recover up to this lsn if
+	lsn_t		limit_lsn);	/*!< in: recover up to this lsn if
 					possible */
-	ulint		first_log_no);	/*!< in: number of the first archived
-					log file to use in the recovery; the
-					file will be searched from
-					INNOBASE_LOG_ARCH_DIR specified in
-					server config file */
 /********************************************************//**
 Completes recovery from archive. */
 UNIV_INTERN
--- a/storage/innobase/include/os0file.h
+++ b/storage/innobase/include/os0file.h
@@ -99,7 +99,7 @@
 if this fails for a log block, then it is equivalent to a media failure in the
 log. */
 
-#define OS_FILE_LOG_BLOCK_SIZE		512
+#define OS_FILE_LOG_BLOCK_SIZE		srv_log_block_size
 
 /** Options for os_file_create_func @{ */
 enum os_file_create_t {
@@ -206,6 +206,10 @@
 extern ulint	os_n_file_writes;
 extern ulint	os_n_fsyncs;
 
+#define OS_MIN_LOG_BLOCK_SIZE 512
+
+extern ulint	srv_log_block_size;
+
 #ifdef UNIV_PFS_IO
 /* Keys to register InnoDB I/O with performance schema */
 extern mysql_pfs_key_t	innodb_file_data_key;
--- a/storage/innobase/include/srv0srv.h
+++ b/storage/innobase/include/srv0srv.h
@@ -353,6 +353,14 @@
 extern ulong	srv_max_purge_lag_delay;
 
 extern ulong	srv_replication_delay;
+
+extern ulint	srv_log_checksum_algorithm;
+
+extern ibool	srv_apply_log_only;
+
+extern ibool	srv_backup_mode;
+extern ibool	srv_close_files;
+
 /*-------------------------------------------*/
 
 extern my_bool	srv_print_innodb_monitor;
@@ -496,13 +504,17 @@
 				the reason for which is that some FS
 				do not flush meta-data when
 				unbuffered IO happens */
-	SRV_UNIX_O_DIRECT_NO_FSYNC
+	SRV_UNIX_O_DIRECT_NO_FSYNC,
 				/*!< do not use fsync() when using
 				direct IO i.e.: it can be set to avoid
 				the fsync() call that we make when
 				using SRV_UNIX_O_DIRECT. However, in
 				this case user/DBA should be sure about
 				the integrity of the meta-data */
+	SRV_UNIX_ALL_O_DIRECT   /*!< similar to O_DIRECT, invokes
+				os_file_set_nocache() on data and log files.
+				This implies using non-buffered IO but still
+				using fsync for data but not log files. */
 };
 
 /** Alternatives for file i/o in Windows */
--- a/storage/innobase/include/srv0start.h
+++ b/storage/innobase/include/srv0start.h
@@ -68,6 +68,23 @@
 srv_add_path_separator_if_needed(
 /*=============================*/
 	char*	str);	/*!< in: null-terminated character string */
+/********************************************************************
+Opens the configured number of undo tablespaces.
+@return	DB_SUCCESS or error code */
+UNIV_INTERN
+dberr_t
+srv_undo_tablespaces_init(
+/*======================*/
+	ibool		create_new_db,		/*!< in: TRUE if new db being
+						created */
+	ibool		backup_mode,		/*!< in: TRUE disables reading
+						the system tablespace (used in
+						XtraBackup), FALSE is passed on
+						recovery. */
+	const ulint	n_conf_tablespaces,	/*!< in: configured undo
+						tablespaces */
+	ulint*		n_opened);		/*!< out: number of UNDO
+						tablespaces successfully */
 #ifndef UNIV_HOTBACKUP
 /****************************************************************//**
 Starts Innobase and creates a new database if database files
--- a/storage/innobase/include/univ.i
+++ b/storage/innobase/include/univ.i
@@ -46,6 +46,9 @@
 #define INNODB_VERSION_MINOR	MYSQL_VERSION_MINOR
 #define INNODB_VERSION_BUGFIX	MYSQL_VERSION_PATCH
 
+/* Enable UNIV_LOG_ARCHIVE in XtraDB */
+#define UNIV_LOG_ARCHIVE 1
+
 /* The following is the InnoDB version as shown in
 SELECT plugin_version FROM information_schema.plugins;
 calculated in make_version_string() in sql/sql_show.cc like this:
--- a/storage/innobase/log/log0log.cc
+++ b/storage/innobase/log/log0log.cc
@@ -79,6 +79,10 @@
 /* Global log system variable */
 UNIV_INTERN log_t*	log_sys	= NULL;
 
+/** Pointer to the log checksum calculation function */
+UNIV_INTERN log_checksum_func_t log_checksum_algorithm_ptr	=
+	log_block_calc_checksum_innodb;
+
 #ifdef UNIV_PFS_RWLOCK
 UNIV_INTERN mysql_pfs_key_t	checkpoint_lock_key;
 # ifdef UNIV_LOG_ARCHIVE
@@ -1003,10 +1007,10 @@
 		mem_zalloc(sizeof(byte**) * n_files));
 
 #ifdef UNIV_LOG_ARCHIVE
-	group->archive_file_header_bufs_ptr = static_cast<byte*>(
+	group->archive_file_header_bufs_ptr = static_cast<byte**>(
 		mem_zalloc( sizeof(byte*) * n_files));
 
-	group->archive_file_header_bufs = static_cast<byte*>(
+	group->archive_file_header_bufs = static_cast<byte**>(
 		mem_zalloc(sizeof(byte*) * n_files));
 #endif /* UNIV_LOG_ARCHIVE */
 
@@ -1031,7 +1035,7 @@
 #ifdef UNIV_LOG_ARCHIVE
 	group->archive_space_id = archive_space_id;
 
-	group->archived_file_no = 0;
+	group->archived_file_no = LOG_START_LSN;
 	group->archived_offset = 0;
 #endif /* UNIV_LOG_ARCHIVE */
 
@@ -1179,6 +1183,7 @@
 		group = (log_group_t*)((ulint) group - 1);
 
 		if (srv_unix_file_flush_method != SRV_UNIX_O_DSYNC
+		    && srv_unix_file_flush_method != SRV_UNIX_ALL_O_DIRECT
 		    && srv_unix_file_flush_method != SRV_UNIX_NOSYNC) {
 
 			fil_flush(group->space_id);
@@ -1200,6 +1205,7 @@
 			logs and cannot end up here! */
 
 	if (srv_unix_file_flush_method != SRV_UNIX_O_DSYNC
+	    && srv_unix_file_flush_method != SRV_UNIX_ALL_O_DIRECT
 	    && srv_unix_file_flush_method != SRV_UNIX_NOSYNC
 	    && srv_flush_log_at_trx_commit != 2) {
 
@@ -1251,6 +1257,11 @@
 	/* Wipe over possible label of ibbackup --restore */
 	memcpy(buf + LOG_FILE_WAS_CREATED_BY_HOT_BACKUP, "    ", 4);
 
+	if (srv_log_block_size > 512) {
+		mach_write_to_4(buf + LOG_FILE_OS_FILE_LOG_BLOCK_SIZE,
+				srv_log_block_size);
+	}
+
 	dest_offset = nth_file * group->file_size;
 
 #ifdef UNIV_DEBUG
@@ -1596,9 +1607,11 @@
 
 	mutex_exit(&(log_sys->mutex));
 
-	if (srv_unix_file_flush_method == SRV_UNIX_O_DSYNC) {
-		/* O_DSYNC means the OS did not buffer the log file at all:
-		so we have also flushed to disk what we have written */
+	if (srv_unix_file_flush_method == SRV_UNIX_O_DSYNC ||
+	    srv_unix_file_flush_method != SRV_UNIX_ALL_O_DIRECT) {
+		/* O_DSYNC or SRV_UNIX_ALL_O_DIRECT means the OS did not buffer
+		the log file at all: so we have also flushed to disk what we
+		have written */
 
 		log_sys->flushed_to_disk_lsn = log_sys->write_lsn;
 
@@ -1856,7 +1869,6 @@
 	log_group_t*	group2;
 #ifdef UNIV_LOG_ARCHIVE
 	ib_uint64_t	archived_lsn;
-	ib_uint64_t	next_archived_lsn;
 #endif /* UNIV_LOG_ARCHIVE */
 	lsn_t		lsn_offset;
 	ulint		write_offset;
@@ -1866,9 +1878,7 @@
 
 	ut_ad(!srv_read_only_mode);
 	ut_ad(mutex_own(&(log_sys->mutex)));
-#if LOG_CHECKPOINT_SIZE > OS_FILE_LOG_BLOCK_SIZE
-# error "LOG_CHECKPOINT_SIZE > OS_FILE_LOG_BLOCK_SIZE"
-#endif
+	ut_ad(LOG_CHECKPOINT_SIZE <= OS_FILE_LOG_BLOCK_SIZE);
 
 	buf = group->checkpoint_buf;
 
@@ -1889,11 +1899,6 @@
 		archived_lsn = LSN_MAX;
 	} else {
 		archived_lsn = log_sys->archived_lsn;
-
-		if (archived_lsn != log_sys->next_archived_lsn) {
-			next_archived_lsn = log_sys->next_archived_lsn;
-			/* For debugging only */
-		}
 	}
 
 	mach_write_to_8(buf + LOG_CHECKPOINT_ARCHIVED_LSN, archived_lsn);
@@ -2089,7 +2094,8 @@
 		recv_apply_hashed_log_recs(TRUE);
 	}
 
-	if (srv_unix_file_flush_method != SRV_UNIX_NOSYNC) {
+	if (srv_unix_file_flush_method != SRV_UNIX_NOSYNC
+	    && srv_unix_file_flush_method != SRV_UNIX_ALL_O_DIRECT) {
 		fil_flush_file_spaces(FIL_TABLESPACE);
 	}
 
@@ -2332,7 +2338,7 @@
 	fil_io(OS_FILE_READ | OS_FILE_LOG, sync, group->space_id, 0,
 	       (ulint) (source_offset / UNIV_PAGE_SIZE),
 	       (ulint) (source_offset % UNIV_PAGE_SIZE),
-	       len, buf, NULL);
+	       len, buf, (type == LOG_ARCHIVE) ? &log_archive_io : NULL);
 
 	start_lsn += len;
 	buf += len;
@@ -2351,12 +2357,68 @@
 log_archived_file_name_gen(
 /*=======================*/
 	char*	buf,	/*!< in: buffer where to write */
+	ulint	buf_len,/*!< in: buffer length */
 	ulint	id __attribute__((unused)),
 			/*!< in: group id;
 			currently we only archive the first group */
-	ulint	file_no)/*!< in: file number */
+	lsn_t	file_no)/*!< in: file number */
 {
-	sprintf(buf, "%sib_arch_log_%010lu", srv_arch_dir, (ulong) file_no);
+	ulint	dirnamelen;
+
+	dirnamelen = strlen(srv_arch_dir);
+
+	ut_a(buf_len > dirnamelen +
+		       IB_ARCHIVED_LOGS_SERIAL_LEN +
+		       IB_ARCHIVED_LOGS_PREFIX_LEN + 2);
+
+	strcpy(buf, srv_arch_dir);
+
+	if (buf[dirnamelen-1] != SRV_PATH_SEPARATOR) {
+		buf[dirnamelen++] = SRV_PATH_SEPARATOR;
+	}
+	sprintf(buf + dirnamelen, IB_ARCHIVED_LOGS_PREFIX
+		"%0" IB_TO_STR(IB_ARCHIVED_LOGS_SERIAL_LEN) "llu",
+		(unsigned long long) file_no);
+}
+
+/******************************************************//**
+Get offset within archived log file to continue to write
+with. */
+UNIV_INTERN
+void
+log_archived_get_offset(
+/*=====================*/
+	log_group_t*	group,		/*!< in: log group */
+	lsn_t		file_no,	/*!< in: archive log file number */
+	lsn_t		archived_lsn,	/*!< in: last archived LSN */
+	lsn_t*		offset)		/*!< out: offset within archived file */
+{
+	char		file_name[OS_FILE_MAX_PATH];
+	ibool		exists;
+	os_file_type_t	type;
+
+	log_archived_file_name_gen(file_name,
+		sizeof(file_name), group->id, file_no);
+
+	ut_a(os_file_status(file_name, &exists,	&type));
+
+	if (!exists) {
+		*offset = 0;
+		return;
+	}
+
+	*offset = archived_lsn - file_no + LOG_FILE_HDR_SIZE;
+
+	if (archived_lsn != LSN_MAX) {
+		*offset = archived_lsn - file_no + LOG_FILE_HDR_SIZE;
+	} else {
+		/* Archiving was OFF prior startup */
+		*offset = 0;
+	}
+
+	ut_a(group->file_size >= *offset + LOG_FILE_HDR_SIZE);
+
+	return;
 }
 
 /******************************************************//**
@@ -2394,6 +2456,7 @@
 	MONITOR_INC(MONITOR_LOG_IO);
 
 	fil_io(OS_FILE_WRITE | OS_FILE_LOG, true, group->archive_space_id,
+	       0,
 	       dest_offset / UNIV_PAGE_SIZE,
 	       dest_offset % UNIV_PAGE_SIZE,
 	       2 * OS_FILE_LOG_BLOCK_SIZE,
@@ -2429,6 +2492,7 @@
 	MONITOR_INC(MONITOR_LOG_IO);
 
 	fil_io(OS_FILE_WRITE | OS_FILE_LOG, true, group->archive_space_id,
+	       0,
 	       dest_offset / UNIV_PAGE_SIZE,
 	       dest_offset % UNIV_PAGE_SIZE,
 	       OS_FILE_LOG_BLOCK_SIZE,
@@ -2483,7 +2547,7 @@
 			open_mode = OS_FILE_OPEN;
 		}
 
-		log_archived_file_name_gen(name, group->id,
+		log_archived_file_name_gen(name, sizeof(name), group->id,
 					   group->archived_file_no + n_files);
 
 		file_handle = os_file_create(innodb_file_log_key,
@@ -2521,8 +2585,8 @@
 
 		/* Add the archive file as a node to the space */
 
-		fil_node_create(name, group->file_size / UNIV_PAGE_SIZE,
-				group->archive_space_id, FALSE);
+		ut_a(fil_node_create(name, group->file_size / UNIV_PAGE_SIZE,
+				     group->archive_space_id, FALSE));
 
 		if (next_offset % group->file_size == 0) {
 			log_group_archive_file_header_write(
@@ -2558,6 +2622,7 @@
 	MONITOR_INC(MONITOR_LOG_IO);
 
 	fil_io(OS_FILE_WRITE | OS_FILE_LOG, false, group->archive_space_id,
+	       0,
 	       (ulint) (next_offset / UNIV_PAGE_SIZE),
 	       (ulint) (next_offset % UNIV_PAGE_SIZE),
 	       ut_calc_align(len, OS_FILE_LOG_BLOCK_SIZE), buf,
@@ -2929,7 +2994,6 @@
 					 trunc_len);
 		if (increment_file_count) {
 			group->archived_offset = 0;
-			group->archived_file_no += 2;
 		}
 
 #ifdef UNIV_DEBUG
@@ -3194,7 +3258,6 @@
 /*=======================================*/
 {
 	lsn_t			lsn;
-	ulint			arch_log_no;
 	ulint			count = 0;
 	ulint			total_trx;
 	ulint			pending_io;
@@ -3411,15 +3474,7 @@
 		goto loop;
 	}
 
-	arch_log_no = 0;
-
 #ifdef UNIV_LOG_ARCHIVE
-	UT_LIST_GET_FIRST(log_sys->log_groups)->archived_file_no;
-
-	if (0 == UT_LIST_GET_FIRST(log_sys->log_groups)->archived_offset) {
-
-		arch_log_no--;
-	}
 
 	log_archive_close_groups(TRUE);
 #endif /* UNIV_LOG_ARCHIVE */
@@ -3478,7 +3533,16 @@
 	srv_shutdown_lsn = lsn;
 
 	if (!srv_read_only_mode) {
-		fil_write_flushed_lsn_to_data_files(lsn, arch_log_no);
+		/*
+		  log_sys->lsn is aligned up to the log block size
+		  in recv_reset_logs(), but if archived logs are applied
+		  data files must contain exactly the same flushed_lsn
+		  on which applying was finished
+		*/
+		fil_write_flushed_lsn_to_data_files(
+			srv_archive_recovery ? recv_sys->recovered_lsn :
+			lsn,
+			0);
 
 		fil_flush_file_spaces(FIL_TABLESPACE);
 	}
@@ -3701,7 +3765,7 @@
 
 #ifdef UNIV_LOG_ARCHIVE
 	rw_lock_free(&log_sys->archive_lock);
-	os_event_create();
+	os_event_free(log_sys->archiving_on);
 #endif /* UNIV_LOG_ARCHIVE */
 
 #ifdef UNIV_LOG_DEBUG
--- a/storage/innobase/log/log0recv.cc
+++ b/storage/innobase/log/log0recv.cc
@@ -48,21 +48,29 @@
 #include "trx0undo.h"
 #include "trx0rec.h"
 #include "fil0fil.h"
-#ifndef UNIV_HOTBACKUP
+//#ifndef UNIV_HOTBACKUP
 # include "buf0rea.h"
 # include "srv0srv.h"
 # include "srv0start.h"
 # include "trx0roll.h"
 # include "row0merge.h"
 # include "sync0sync.h"
-#else /* !UNIV_HOTBACKUP */
+//#else /* !UNIV_HOTBACKUP */
+#include "xb0xb.h"
+
+/** The size of archived log file */
+extern ib_uint64_t xtrabackup_arch_file_size;
+/** The minimal LSN of found archived log files */
+extern ib_uint64_t xtrabackup_arch_first_file_lsn;
+/** The maximum LSN of found archived log files */
+extern ib_uint64_t xtrabackup_arch_last_file_lsn;
 
 
 /** This is set to FALSE if the backup was originally taken with the
 ibbackup --include regexp option: then we do not want to create tables in
 directories which were not included */
 UNIV_INTERN ibool	recv_replay_file_ops	= TRUE;
-#endif /* !UNIV_HOTBACKUP */
+//#endif /* !UNIV_HOTBACKUP */
 
 /** Log records are stored in the hash table in chunks at most of this size;
 this must be less than UNIV_PAGE_SIZE as it is stored in the buffer pool */
@@ -405,7 +413,7 @@
 	/* Set appropriate value of recv_n_pool_free_frames. */
 	if (buf_pool_get_curr_size() >= (10 * 1024 * 1024)) {
 		/* Buffer pool of size greater than 10 MB. */
-		recv_n_pool_free_frames = 512;
+		recv_n_pool_free_frames = 1024;
 	}
 
 	recv_sys->buf = static_cast<byte*>(ut_malloc(RECV_PARSING_BUF_SIZE));
@@ -712,7 +720,7 @@
 /***********************************************************************//**
 Checks the consistency of the checkpoint info
 @return	TRUE if ok */
-static
+UNIV_INTERN
 ibool
 recv_check_cp_is_consistent(
 /*========================*/
@@ -742,7 +750,7 @@
 /********************************************************//**
 Looks for the maximum consistent checkpoint from the log groups.
 @return	error code or DB_SUCCESS */
-static __attribute__((nonnull, warn_unused_result))
+UNIV_INTERN __attribute__((nonnull, warn_unused_result))
 dberr_t
 recv_find_max_checkpoint(
 /*=====================*/
@@ -902,7 +910,7 @@
 InnoDB-3.23.52 where the checksum field contains the log block number.
 @return TRUE if ok, or if the log block may be in the format of InnoDB
 version predating 3.23.52 */
-static
+UNIV_INTERN
 ibool
 log_block_checksum_is_ok_or_old_format(
 /*===================================*/
@@ -911,12 +919,72 @@
 #ifdef UNIV_LOG_DEBUG
 	return(TRUE);
 #endif /* UNIV_LOG_DEBUG */
-	if (log_block_calc_checksum(block) == log_block_get_checksum(block)) {
+
+	ulint block_checksum = log_block_get_checksum(block);
+
+	if (UNIV_LIKELY(srv_log_checksum_algorithm ==
+			SRV_CHECKSUM_ALGORITHM_NONE ||
+			log_block_calc_checksum(block) == block_checksum)) {
+
+		return(TRUE);
+	}
+
+	if (srv_log_checksum_algorithm == SRV_CHECKSUM_ALGORITHM_STRICT_CRC32 ||
+	    srv_log_checksum_algorithm == SRV_CHECKSUM_ALGORITHM_STRICT_INNODB ||
+	    srv_log_checksum_algorithm == SRV_CHECKSUM_ALGORITHM_STRICT_NONE) {
+
+		const char*	algo = NULL;
+
+		ib_logf(IB_LOG_LEVEL_ERROR,
+			"log block checksum mismatch: expected " ULINTPF ", "
+			"calculated checksum " ULINTPF,
+			block_checksum,
+			log_block_calc_checksum(block));
+
+		if (block_checksum == LOG_NO_CHECKSUM_MAGIC) {
+
+			algo = "none";
+		} else if (block_checksum ==
+			   log_block_calc_checksum_crc32(block)) {
+
+			algo = "crc32";
+		} else if (block_checksum ==
+			   log_block_calc_checksum_innodb(block)) {
+
+			algo = "innodb";
+		}
+
+		if (algo) {
+
+			const char*	current_algo;
+
+			current_algo = buf_checksum_algorithm_name(
+				(srv_checksum_algorithm_t)
+				srv_log_checksum_algorithm);
+
+			ib_logf(IB_LOG_LEVEL_ERROR,
+				"current InnoDB log checksum type: %s, "
+				"detected log checksum type: %s",
+				current_algo,
+				algo);
+		}
+
+		ib_logf(IB_LOG_LEVEL_FATAL,
+			"STRICT method was specified for innodb_log_checksum, "
+			"so we intentionally assert here.");
+	}
+
+	ut_ad(srv_log_checksum_algorithm == SRV_CHECKSUM_ALGORITHM_CRC32 ||
+	      srv_log_checksum_algorithm == SRV_CHECKSUM_ALGORITHM_INNODB);
+
+	if (block_checksum == LOG_NO_CHECKSUM_MAGIC ||
+	    block_checksum == log_block_calc_checksum_crc32(block) ||
+	    block_checksum == log_block_calc_checksum_innodb(block)) {
 
 		return(TRUE);
 	}
 
-	if (log_block_get_hdr_no(block) == log_block_get_checksum(block)) {
+	if (log_block_get_hdr_no(block) == block_checksum) {
 
 		/* We assume the log block is in the format of
 		InnoDB version < 3.23.52 and the block is ok */
@@ -1606,6 +1674,8 @@
 					     buf_block_get_page_no(block));
 
 	if ((recv_addr == NULL)
+	    /* Fix for http://bugs.mysql.com/bug.php?id=44140 */
+	    || (recv_addr->state == RECV_BEING_READ && !just_read_in)
 	    || (recv_addr->state == RECV_BEING_PROCESSED)
 	    || (recv_addr->state == RECV_PROCESSED)) {
 
@@ -1695,9 +1765,17 @@
 			if (page_zip) {
 				memset(FIL_PAGE_LSN + page_zip->data, 0, 8);
 			}
+
+			if (!block->page.is_compacted
+			    && block->page.is_compacted) {
+
+				ut_ad(srv_compact_backup);
+
+				block->page.is_compacted = FALSE;
+			}
 		}
 
-		if (recv->start_lsn >= page_lsn) {
+		if (!block->page.is_compacted && recv->start_lsn >= page_lsn) {
 
 			lsn_t	end_lsn;
 
@@ -1883,6 +1961,19 @@
 			ulint	zip_size = fil_space_get_zip_size(space);
 			ulint	page_no = recv_addr->page_no;
 
+			/* By now we have replayed all DDL log records from the
+			current batch. Check if the space ID is still valid in
+			the entry being processed, and ignore it if it is not.*/
+			if (fil_tablespace_deleted_or_being_deleted_in_mem(
+				    space, -1)) {
+
+				ut_a(recv_sys->n_addrs);
+
+				recv_addr->state = RECV_PROCESSED;
+				recv_sys->n_addrs--;
+
+				continue;
+			}
 			if (recv_addr->state == RECV_NOT_PROCESSED) {
 				if (!has_printed) {
 					ib_logf(IB_LOG_LEVEL_INFO,
@@ -2424,7 +2515,7 @@
 			   || type == MLOG_FILE_RENAME
 			   || type == MLOG_FILE_DELETE) {
 			ut_a(space);
-#ifdef UNIV_HOTBACKUP
+//#ifdef UNIV_HOTBACKUP
 			if (recv_replay_file_ops) {
 
 				/* In ibbackup --apply-log, replay an .ibd file
@@ -2447,7 +2538,7 @@
 					ut_error;
 				}
 			}
-#endif
+//#endif
 			/* In normal mysqld crash recovery we do not try to
 			replay file operations */
 #ifdef UNIV_LOG_LSN_DEBUG
@@ -2850,7 +2941,10 @@
 				= log_block_get_checkpoint_no(log_block);
 		}
 
-		if (data_len < OS_FILE_LOG_BLOCK_SIZE) {
+		/* Stop scanning if scanned lsn reaches lsn limit */
+		if (data_len < OS_FILE_LOG_BLOCK_SIZE ||
+		    (recv_sys->limit_lsn &&
+		    recv_sys->scanned_lsn >= recv_sys->limit_lsn)) {
 			/* Log data for this group ends here */
 
 			finished = TRUE;
@@ -2870,8 +2964,14 @@
 
 			fprintf(stderr,
 				"InnoDB: Doing recovery: scanned up to"
-				" log sequence number " LSN_PF "\n",
-				*group_scanned_lsn);
+				" log sequence number " LSN_PF " (%lu%%)\n",
+				*group_scanned_lsn,
+				(ulong) ((*group_scanned_lsn
+					  - recv_sys->parse_start_lsn)
+					 / (8 * log_group_get_capacity(
+						UT_LIST_GET_FIRST(
+						    log_sys->log_groups))
+					    / 900)));
 		}
 	}
 
@@ -2971,7 +3071,7 @@
 	ib_logf(IB_LOG_LEVEL_INFO,
 		"Reading tablespace information from the .ibd files...");
 
-	fil_load_single_table_tablespaces();
+	fil_load_single_table_tablespaces(NULL);
 
 	/* If we are using the doublewrite method, we will
 	check if there are half-written pages in data files,
@@ -3015,6 +3115,7 @@
 	log_group_t*	group;
 	log_group_t*	max_cp_group;
 	ulint		max_cp_field;
+	ulint		log_hdr_log_block_size;
 	lsn_t		checkpoint_lsn;
 	ib_uint64_t	checkpoint_no;
 	lsn_t		group_scanned_lsn = 0;
@@ -3024,10 +3125,14 @@
 	lsn_t		archived_lsn;
 #endif /* UNIV_LOG_ARCHIVE */
 	byte*		buf;
-	byte		log_hdr_buf[LOG_FILE_HDR_SIZE];
+	byte*		log_hdr_buf;
+	byte		log_hdr_buf_base[LOG_FILE_HDR_SIZE + OS_FILE_LOG_BLOCK_SIZE];
 	dberr_t		err;
 	ut_when_dtor<recv_dblwr_t> tmp(recv_sys->dblwr);
 
+	log_hdr_buf = static_cast<byte *>
+		(ut_align(log_hdr_buf_base, OS_FILE_LOG_BLOCK_SIZE));
+
 #ifdef UNIV_LOG_ARCHIVE
 	ut_ad(type != LOG_CHECKPOINT || limit_lsn == LSN_MAX);
 /** TRUE when recovering from a checkpoint */
@@ -3116,14 +3221,33 @@
 		       log_hdr_buf, max_cp_group);
 	}
 
+	log_hdr_log_block_size
+		= mach_read_from_4(log_hdr_buf + LOG_FILE_OS_FILE_LOG_BLOCK_SIZE);
+	if (log_hdr_log_block_size == 0) {
+		/* 0 means default value */
+		log_hdr_log_block_size = 512;
+	}
+	if (UNIV_UNLIKELY(log_hdr_log_block_size != srv_log_block_size)) {
+		fprintf(stderr,
+			"InnoDB: Error: The block size of ib_logfile (" ULINTPF
+			") is not equal to innodb_log_block_size.\n"
+			"InnoDB: Error: Suggestion - Recreate log files.\n",
+			log_hdr_log_block_size);
+		return(DB_ERROR);
+	}
+
 #ifdef UNIV_LOG_ARCHIVE
 	group = UT_LIST_GET_FIRST(log_sys->log_groups);
 
 	while (group) {
+		/* There is no need to read archived_file_no and
+		archived_offset because they are calculated another
+		way */
+		/*
 		log_checkpoint_get_nth_group_info(buf, group->id,
 						  &(group->archived_file_no),
 						  &(group->archived_offset));
-
+		*/
 		group = UT_LIST_GET_NEXT(log_groups, group);
 	}
 #endif /* UNIV_LOG_ARCHIVE */
@@ -3444,7 +3568,8 @@
 	that the data dictionary tables will be free of any locks.
 	The data dictionary latch should guarantee that there is at
 	most one data dictionary transaction active at a time. */
-	if (srv_force_recovery < SRV_FORCE_NO_TRX_UNDO) {
+	if (srv_force_recovery < SRV_FORCE_NO_TRX_UNDO
+	    && !srv_apply_log_only) {
 		trx_rollback_or_clean_recovered(FALSE);
 	}
 }
@@ -3673,23 +3798,23 @@
 	ulint		len;
 	ibool		ret;
 	byte*		buf;
-	os_offset_t	read_offset;
+	os_offset_t	read_offset = 0;
 	os_offset_t	file_size;
 	int		input_char;
-	char		name[10000];
+	char		name[OS_FILE_MAX_PATH];
 
-	ut_a(0);
 
 try_open_again:
 	buf = log_sys->buf;
 
 	/* Add the file to the archive file space; open the file */
 
-	log_archived_file_name_gen(name, group->id, group->archived_file_no);
+	log_archived_file_name_gen(name, sizeof(name),
+				   group->id, group->archived_file_no);
 
 	file_handle = os_file_create(innodb_file_log_key,
 				     name, OS_FILE_OPEN,
-				     OS_FILE_LOG, OS_FILE_AIO, &ret);
+				     OS_FILE_AIO, OS_LOG_FILE, &ret);
 
 	if (ret == FALSE) {
 ask_again:
@@ -3734,20 +3859,19 @@
 
 	/* Add the archive file as a node to the space */
 
-	fil_node_create(name, 1 + file_size / UNIV_PAGE_SIZE,
-			group->archive_space_id, FALSE);
-#if RECV_SCAN_SIZE < LOG_FILE_HDR_SIZE
-# error "RECV_SCAN_SIZE < LOG_FILE_HDR_SIZE"
-#endif
+	ut_a(fil_node_create(name, 1 + file_size / UNIV_PAGE_SIZE,
+			     group->archive_space_id, FALSE));
+	ut_a(RECV_SCAN_SIZE >= LOG_FILE_HDR_SIZE);
 
 	/* Read the archive file header */
-	fil_io(OS_FILE_READ | OS_FILE_LOG, true, group->archive_space_id, 0, 0,
+	fil_io(OS_FILE_READ | OS_FILE_LOG, true, group->archive_space_id, 0,
+	       0, 0,
 	       LOG_FILE_HDR_SIZE, buf, NULL);
 
 	/* Check if the archive file header is consistent */
 
 	if (mach_read_from_4(buf + LOG_GROUP_ID) != group->id
-	    || mach_read_from_4(buf + LOG_FILE_NO)
+	    || mach_read_from_8(buf + LOG_FILE_START_LSN)
 	    != group->archived_file_no) {
 		fprintf(stderr,
 			"InnoDB: Archive file header inconsistent %s\n", name);
@@ -3776,6 +3900,20 @@
 			return(TRUE);
 		}
 
+		/*
+		  if this is the first file of scanning set
+		  calculate offset of the first log record
+		*/
+		if (recv_sys->parse_start_lsn >= start_lsn &&
+		    recv_sys->parse_start_lsn < file_end_lsn) {
+			read_offset = ut_calc_align_down(
+				recv_sys->parse_start_lsn - start_lsn,
+				OS_FILE_LOG_BLOCK_SIZE);
+			start_lsn = ut_calc_align_down(
+				recv_sys->parse_start_lsn,
+				OS_FILE_LOG_BLOCK_SIZE);
+		}
+
 		recv_sys->scanned_lsn = start_lsn;
 	}
 
@@ -3788,7 +3926,7 @@
 		return(TRUE);
 	}
 
-	read_offset = LOG_FILE_HDR_SIZE;
+	read_offset += LOG_FILE_HDR_SIZE;
 
 	for (;;) {
 		len = RECV_SCAN_SIZE;
@@ -3808,13 +3946,13 @@
 			fprintf(stderr,
 				"InnoDB: Archive read starting at"
 				" lsn %llu, len %lu from file %s\n",
-				start_lsn,
+				(unsigned long long) start_lsn,
 				(ulong) len, name);
 		}
 #endif /* UNIV_DEBUG */
 
 		fil_io(OS_FILE_READ | OS_FILE_LOG, true,
-		       group->archive_space_id, read_offset / UNIV_PAGE_SIZE,
+		       group->archive_space_id, 0, read_offset / UNIV_PAGE_SIZE,
 		       read_offset % UNIV_PAGE_SIZE, len, buf, NULL);
 
 		ret = recv_scan_log_recs(
@@ -3829,10 +3967,12 @@
 		}
 
 		if (ret) {
-			fprintf(stderr,
-				"InnoDB: Archive log file %s"
-				" does not scan right\n",
-				name);
+			if (recv_sys->scanned_lsn < recv_sys->limit_lsn) {
+				fprintf(stderr,
+					"InnoDB: Archive log file %s"
+					" does not scan right\n",
+					name);
+			}
 			return(TRUE);
 		}
 
@@ -3849,26 +3989,18 @@
 Recovers from archived log files, and also from log files, if they exist.
 @return	error code or DB_SUCCESS */
 UNIV_INTERN
-ulint
+dberr_t
 recv_recovery_from_archive_start(
 /*=============================*/
 	ib_uint64_t	min_flushed_lsn,/*!< in: min flushed lsn field from the
 					data files */
-	ib_uint64_t	limit_lsn,	/*!< in: recover up to this lsn if
+	ib_uint64_t	limit_lsn)	/*!< in: recover up to this lsn if
 					possible */
-	ulint		first_log_no)	/*!< in: number of the first archived
-					log file to use in the recovery; the
-					file will be searched from
-					INNOBASE_LOG_ARCH_DIR specified in
-					server config file */
 {
 	log_group_t*	group;
 	ulint		group_id;
 	ulint		trunc_len;
 	ibool		ret;
-	ulint		err;
-
-	ut_a(0);
 
 	recv_sys_create();
 	recv_sys_init(buf_pool_get_curr_size());
@@ -3898,7 +4030,7 @@
 		return(DB_ERROR);
 	}
 
-	group->archived_file_no = first_log_no;
+	group->archived_file_no = xtrabackup_arch_first_file_lsn;
 
 	recv_sys->parse_start_lsn = min_flushed_lsn;
 
@@ -3912,7 +4044,8 @@
 
 	mutex_enter(&(log_sys->mutex));
 
-	while (!ret) {
+	while (!ret &&
+	       group->archived_file_no <= xtrabackup_arch_last_file_lsn) {
 		ret = log_group_recover_from_archive_file(group);
 
 		/* Close and truncate a possible processed archive file
@@ -3925,9 +4058,9 @@
 						 trunc_len);
 		}
 
-		group->archived_file_no++;
+		group->archived_file_no += group->file_size - LOG_FILE_HDR_SIZE;
 	}
-
+/*
 	if (recv_sys->recovered_lsn < limit_lsn) {
 
 		if (!recv_sys->scanned_lsn) {
@@ -3948,12 +4081,12 @@
 
 		mutex_enter(&(log_sys->mutex));
 	}
-
+*/
 	if (limit_lsn != LSN_MAX) {
 
 		recv_apply_hashed_log_recs(FALSE);
 
-		recv_reset_logs(0, FALSE, recv_sys->recovered_lsn);
+	//	recv_reset_logs(0, FALSE, recv_sys->recovered_lsn);
 	}
 
 	mutex_exit(&(log_sys->mutex));
--- a/storage/innobase/mem/mem0dbg.cc
+++ b/storage/innobase/mem/mem0dbg.cc
@@ -278,18 +278,10 @@
 	byte*	buf,	/*!< in: pointer to buffer */
 	ulint	 n)	/*!< in: length of buffer */
 {
-	byte*	ptr;
-
 	UNIV_MEM_ASSERT_W(buf, n);
 
-	for (ptr = buf; ptr < buf + n; ptr++) {
-
-		if (ut_rnd_gen_ibool()) {
-			*ptr = 0xBA;
-		} else {
-			*ptr = 0xBE;
-		}
-	}
+	/* Fix https://bugs.launchpad.net/percona-xtrabackup/+bug/1158154 */
+	memset(buf, 0xBA, n);
 
 	UNIV_MEM_INVALID(buf, n);
 }
@@ -304,17 +296,10 @@
 	byte*	buf,	/*!< in: pointer to buffer */
 	ulint	n)	/*!< in: length of buffer */
 {
-	byte*	ptr;
-
 	UNIV_MEM_ASSERT_W(buf, n);
 
-	for (ptr = buf; ptr < buf + n; ptr++) {
-		if (ut_rnd_gen_ibool()) {
-			*ptr = 0xDE;
-		} else {
-			*ptr = 0xAD;
-		}
-	}
+	/* Fix https://bugs.launchpad.net/percona-xtrabackup/+bug/1158154 */
+	memset(buf, 0xDE, n);
 
 	UNIV_MEM_FREE(buf, n);
 }
--- a/storage/innobase/os/os0file.cc
+++ b/storage/innobase/os/os0file.cc
@@ -691,7 +691,7 @@
 }
 
 #undef USE_FILE_LOCK
-#define USE_FILE_LOCK
+//#define USE_FILE_LOCK
 #if defined(UNIV_HOTBACKUP) || defined(__WIN__)
 /* InnoDB Hot Backup does not lock the data files.
  * On Windows, mandatory locking is used.
@@ -839,6 +839,10 @@
 
 	if (dir == NULL && error_is_fatal) {
 		os_file_handle_error(dirname, "opendir");
+
+		/* Exit even if error is a "known" error, in which case
+		os_file_handle_error() will not abort. */
+		exit(1);
 	}
 
 	return(dir);
@@ -1755,8 +1759,6 @@
 
 	} while (retry);
 
-	/* We disable OS caching (O_DIRECT) only on data files */
-
 	if (!srv_read_only_mode
 	    && *success
 	    && type != OS_LOG_FILE
@@ -1764,6 +1766,11 @@
 		|| srv_unix_file_flush_method == SRV_UNIX_O_DIRECT_NO_FSYNC)) {
 
 		os_file_set_nocache(file, name, mode_str);
+	} else if (!srv_read_only_mode
+	    && *success
+	    && srv_unix_file_flush_method == SRV_UNIX_ALL_O_DIRECT) {
+
+		os_file_set_nocache(file, name, mode_str);
 	}
 
 #ifdef USE_FILE_LOCK
--- a/storage/innobase/page/page0cur.cc
+++ b/storage/innobase/page/page0cur.cc
@@ -1209,7 +1209,9 @@
 	      || (mtr ? mtr->inside_ibuf : dict_index_is_ibuf(index)));
 
 	ut_ad(!page_cur_is_after_last(cursor));
-#ifdef UNIV_ZIP_DEBUG
+#if 0
+	/* Disabled to speedup compact_compressed test for debug XtraBackup
+	builds, see LP bug #1213036. */
 	ut_a(page_zip_validate(page_zip, page, index));
 #endif /* UNIV_ZIP_DEBUG */
 
--- a/storage/innobase/srv/srv0srv.cc
+++ b/storage/innobase/srv/srv0srv.cc
@@ -239,6 +239,10 @@
 
 /* Switch to enable random read ahead. */
 UNIV_INTERN my_bool	srv_random_read_ahead	= FALSE;
+
+/* The log block size */
+UNIV_INTERN ulint	srv_log_block_size	= 0;
+
 /* User settable value of the number of pages that must be present
 in the buffer cache and accessed sequentially for InnoDB to trigger a
 readahead request. */
@@ -349,6 +353,14 @@
 
 UNIV_INTERN ulong	srv_replication_delay		= 0;
 
+UNIV_INTERN ibool	srv_apply_log_only	= FALSE;
+
+UNIV_INTERN ibool	srv_backup_mode	= FALSE;
+UNIV_INTERN ibool	srv_close_files = TRUE;
+
+UNIV_INTERN ulint	srv_log_checksum_algorithm =
+	SRV_CHECKSUM_ALGORITHM_INNODB;
+
 /*-------------------------------------------*/
 UNIV_INTERN ulong	srv_n_spin_wait_rounds	= 30;
 UNIV_INTERN ulong	srv_spin_wait_delay	= 6;
@@ -1818,7 +1830,8 @@
 	if (ret == SRV_NONE
 	    && srv_shutdown_state != SRV_SHUTDOWN_NONE
 	    && trx_purge_state() != PURGE_STATE_DISABLED
-	    && trx_purge_state() != PURGE_STATE_EXIT) {
+	    && trx_purge_state() != PURGE_STATE_EXIT
+	    && trx_purge_state() != PURGE_STATE_INIT) {
 
 		ret = SRV_PURGE;
 	}
--- a/storage/innobase/srv/srv0start.cc
+++ b/storage/innobase/srv/srv0start.cc
@@ -66,6 +66,7 @@
 #include "ibuf0ibuf.h"
 #include "srv0start.h"
 #include "srv0srv.h"
+#include "xb0xb.h"
 #ifndef UNIV_HOTBACKUP
 # include "trx0rseg.h"
 # include "os0proc.h"
@@ -124,7 +125,7 @@
 UNIV_INTERN enum srv_shutdown_state	srv_shutdown_state = SRV_SHUTDOWN_NONE;
 
 /** Files comprising the system tablespace */
-static os_file_t	files[1000];
+os_file_t	files[1000];
 
 /** io_handler_thread parameters for thread identification */
 static ulint		n[SRV_MAX_N_IO_THREADS + 6];
@@ -663,6 +664,12 @@
 		}
 	}
 
+#ifdef UNIV_LOG_ARCHIVE
+        /* Create the file space object for archived logs. */
+	fil_space_create("arch_log_space", SRV_LOG_SPACE_FIRST_ID + 1,
+			 0, FIL_LOG);
+#endif
+
 	log_group_init(0, srv_n_log_files,
 		       srv_log_file_size * UNIV_PAGE_SIZE,
 		       SRV_LOG_SPACE_FIRST_ID,
@@ -673,7 +680,12 @@
 	/* Create a log checkpoint. */
 	mutex_enter(&log_sys->mutex);
 	ut_d(recv_no_log_write = FALSE);
-	recv_reset_logs(lsn);
+	recv_reset_logs(
+#ifdef UNIV_LOG_ARCHIVE
+		UT_LIST_GET_FIRST(log_sys->log_groups)->archived_file_no,
+		TRUE,
+#endif
+		lsn);
 	mutex_exit(&log_sys->mutex);
 
 	return(DB_SUCCESS);
@@ -754,18 +766,12 @@
 /*********************************************************************//**
 Creates or opens database data files and closes them.
 @return	DB_SUCCESS or error code */
-static __attribute__((nonnull, warn_unused_result))
+UNIV_INTERN __attribute__((nonnull, warn_unused_result))
 dberr_t
 open_or_create_data_files(
 /*======================*/
 	ibool*		create_new_db,	/*!< out: TRUE if new database should be
 					created */
-#ifdef UNIV_LOG_ARCHIVE
-	ulint*		min_arch_log_no,/*!< out: min of archived log
-					numbers in data files */
-	ulint*		max_arch_log_no,/*!< out: max of archived log
-					numbers in data files */
-#endif /* UNIV_LOG_ARCHIVE */
 	lsn_t*		min_flushed_lsn,/*!< out: min of flushed lsn
 					values in data files */
 	lsn_t*		max_flushed_lsn,/*!< out: max of flushed lsn
@@ -989,17 +995,16 @@
 			/* This is the earliest location where we can load
 			the double write buffer. */
 			if (i == 0) {
-				buf_dblwr_init_or_load_pages(
-					files[i], srv_data_file_names[i], true);
+				/* XtraBackup never loads corrupted pages from
+				the doublewrite buffer */
+ 				buf_dblwr_init_or_load_pages(
+					files[i], srv_data_file_names[i], false);
 			}
 
 			bool retry = true;
 check_first_page:
 			check_msg = fil_read_first_page(
 				files[i], one_opened, &flags, &space,
-#ifdef UNIV_LOG_ARCHIVE
-				min_arch_log_no, max_arch_log_no,
-#endif /* UNIV_LOG_ARCHIVE */
 				min_flushed_lsn, max_flushed_lsn);
 
 			if (check_msg) {
@@ -1267,12 +1272,16 @@
 /********************************************************************
 Opens the configured number of undo tablespaces.
 @return	DB_SUCCESS or error code */
-static
+UNIV_INTERN
 dberr_t
 srv_undo_tablespaces_init(
 /*======================*/
 	ibool		create_new_db,		/*!< in: TRUE if new db being
 						created */
+	ibool		backup_mode,		/*!< in: TRUE disables reading
+						the system tablespace (used in
+						XtraBackup), FALSE is passed on
+						recovery. */
 	const ulint	n_conf_tablespaces,	/*!< in: configured undo
 						tablespaces */
 	ulint*		n_opened)		/*!< out: number of UNDO
@@ -1288,6 +1297,7 @@
 	*n_opened = 0;
 
 	ut_a(n_conf_tablespaces <= TRX_SYS_N_RSEGS);
+	ut_a(!create_new_db || !backup_mode);
 
 	memset(undo_tablespace_ids, 0x0, sizeof(undo_tablespace_ids));
 
@@ -1321,12 +1331,13 @@
 		}
 	}
 
-	/* Get the tablespace ids of all the undo segments excluding
-	the system tablespace (0). If we are creating a new instance then
+	/* Get the tablespace ids of all the undo segments excluding the system
+	tablespace (0). If we are creating a new instance then
 	we build the undo_tablespace_ids ourselves since they don't
-	already exist. */
+	already exist. If we are in the backup mode, don't read the trx header,
+	we just need to add all available undo tablespaces to fil_system. */
 
-	if (!create_new_db) {
+	if (!create_new_db && !backup_mode) {
 		n_undo_tablespaces = trx_rseg_get_n_undo_tablespaces(
 			undo_tablespace_ids);
 	} else {
@@ -1432,7 +1443,7 @@
 		ib_logf(IB_LOG_LEVEL_INFO, "Opened %lu undo tablespaces",
 			n_undo_tablespaces);
 
-		if (n_conf_tablespaces == 0) {
+		if (n_conf_tablespaces == 0 && !backup_mode) {
 			ib_logf(IB_LOG_LEVEL_WARN,
 				"Using the system tablespace for all UNDO "
 				"logging because innodb_undo_tablespaces=0");
@@ -1506,8 +1517,8 @@
 	lsn_t		min_flushed_lsn;
 	lsn_t		max_flushed_lsn;
 #ifdef UNIV_LOG_ARCHIVE
-	ulint		min_arch_log_no;
-	ulint		max_arch_log_no;
+	lsn_t		min_arch_log_no;
+	lsn_t		max_arch_log_no;
 #endif /* UNIV_LOG_ARCHIVE */
 	ulint		sum_of_new_sizes;
 	ulint		sum_of_data_file_sizes;
@@ -1740,6 +1751,9 @@
 	} else if (0 == ut_strcmp(srv_file_flush_method_str, "O_DIRECT")) {
 		srv_unix_file_flush_method = SRV_UNIX_O_DIRECT;
 
+	} else if (0 == ut_strcmp(srv_file_flush_method_str, "ALL_O_DIRECT")) {
+		srv_unix_file_flush_method = SRV_UNIX_ALL_O_DIRECT;
+
 	} else if (0 == ut_strcmp(srv_file_flush_method_str, "O_DIRECT_NO_FSYNC")) {
 		srv_unix_file_flush_method = SRV_UNIX_O_DIRECT_NO_FSYNC;
 
@@ -1972,17 +1986,6 @@
 		os_thread_create(io_handler_thread, n + i, thread_ids + i);
 	}
 
-#ifdef UNIV_LOG_ARCHIVE
-	if (0 != ut_strcmp(srv_log_group_home_dir, srv_arch_dir)) {
-		ut_print_timestamp(stderr);
-		fprintf(stderr, " InnoDB: Error: you must set the log group home dir in my.cnf\n");
-		ut_print_timestamp(stderr);
-		fprintf(stderr, " InnoDB: the same as log arch dir.\n");
-
-		return(DB_ERROR);
-	}
-#endif /* UNIV_LOG_ARCHIVE */
-
 	if (srv_n_log_files * srv_log_file_size * UNIV_PAGE_SIZE
 	    >= 512ULL * 1024ULL * 1024ULL * 1024ULL) {
 		/* log_block_convert_lsn_to_no() limits the returned block
@@ -2044,9 +2047,6 @@
 	recv_sys_init(buf_pool_get_curr_size());
 
 	err = open_or_create_data_files(&create_new_db,
-#ifdef UNIV_LOG_ARCHIVE
-					&min_arch_log_no, &max_arch_log_no,
-#endif /* UNIV_LOG_ARCHIVE */
 					&min_flushed_lsn, &max_flushed_lsn,
 					&sum_of_new_sizes);
 	if (err == DB_FAIL) {
@@ -2074,7 +2074,6 @@
 
 #ifdef UNIV_LOG_ARCHIVE
 	srv_normalize_path_for_win(srv_arch_dir);
-	srv_arch_dir = srv_add_path_separator_if_needed(srv_arch_dir);
 #endif /* UNIV_LOG_ARCHIVE */
 
 	dirnamelen = strlen(srv_log_group_home_dir);
@@ -2154,15 +2153,23 @@
 						max_flushed_lsn, logfile0);
 
 					/* Suppress the message about
-					crash recovery. */
-					max_flushed_lsn = min_flushed_lsn
-						= log_get_lsn();
+					crash recovery. If archive recovery
+					is enabled the min/max_flushed_lsn
+					must point to the position from
+					which applying is started. */
+					if (!srv_archive_recovery) {
+						max_flushed_lsn = min_flushed_lsn
+							= log_get_lsn();
+					}
+
 					goto files_checked;
+#if 0
 				} else if (i < 2) {
 					/* must have at least 2 log files */
 					ib_logf(IB_LOG_LEVEL_ERROR,
 						"Only one log file found.");
 					return(err);
+#endif
 				}
 
 				/* opened all files */
@@ -2255,6 +2262,7 @@
 
 	err = srv_undo_tablespaces_init(
 		create_new_db,
+		FALSE,
 		srv_undo_tablespaces,
 		&srv_undo_tablespaces_open);
 
@@ -2328,10 +2336,13 @@
 
 		ib_logf(IB_LOG_LEVEL_INFO,
 			" Starting archive recovery from a backup...");
+		/* Load table spaces before recovery as during recovery
+		there can be log records that are applied to the spaces
+		with unknown id's */
+		fil_load_single_table_tablespaces(NULL);
 
 		err = recv_recovery_from_archive_start(
-			min_flushed_lsn, srv_archive_recovery_limit_lsn,
-			min_arch_log_no);
+			min_flushed_lsn, srv_archive_recovery_limit_lsn);
 		if (err != DB_SUCCESS) {
 
 			return(DB_ERROR);
@@ -2356,6 +2367,11 @@
 		srv_startup_is_before_trx_rollback_phase = FALSE;
 
 		recv_recovery_from_archive_finish();
+
+		if (srv_apply_log_only) {
+			goto skip_processes;
+		}
+
 #endif /* UNIV_LOG_ARCHIVE */
 	} else {
 
@@ -2422,6 +2438,10 @@
 
 		recv_recovery_from_checkpoint_finish();
 
+		if (srv_apply_log_only) {
+			goto skip_processes;
+		}
+
 		if (srv_force_recovery < SRV_FORCE_NO_IBUF_MERGE) {
 			/* The following call is necessary for the insert
 			buffer to work with multiple tablespaces. We must
@@ -2544,7 +2564,9 @@
 		value.  Important to note that we can do it ONLY after
 		we have finished the recovery process so that the
 		image of TRX_SYS_PAGE_NO is not stale. */
-		trx_sys_file_format_tag_init();
+		if (!srv_read_only_mode) {
+			trx_sys_file_format_tag_init();
+		}
 	}
 
 	if (!create_new_db && sum_of_new_sizes > 0) {
@@ -2567,6 +2589,8 @@
 	if (!srv_log_archive_on) {
 		ut_a(DB_SUCCESS == log_archive_noarchivelog());
 	} else {
+		bool	start_archive;
+
 		mutex_enter(&(log_sys->mutex));
 
 		start_archive = FALSE;
@@ -2758,6 +2782,7 @@
 	    && srv_auto_extend_last_data_file
 	    && sum_of_data_file_sizes < tablespace_size_in_header) {
 
+#ifdef UNDEFINED
 		ut_print_timestamp(stderr);
 		fprintf(stderr,
 			" InnoDB: Error: tablespace size stored in header"
@@ -2794,6 +2819,7 @@
 
 			return(DB_ERROR);
 		}
+#endif
 	}
 
 	/* Check that os_fast_mutexes work as expected */
@@ -2818,6 +2844,10 @@
 
 	os_fast_mutex_free(&srv_os_test_mutex);
 
+	if (srv_rebuild_indexes) {
+		xb_compact_rebuild_indexes();
+	}
+
 	if (srv_print_verbose_log) {
 		ib_logf(IB_LOG_LEVEL_INFO,
 			"%s started; log sequence number " LSN_PF "",
@@ -2850,6 +2880,7 @@
 		fts_optimize_init();
 	}
 
+skip_processes:
 	srv_was_started = TRUE;
 
 	return(DB_SUCCESS);
@@ -2905,7 +2936,7 @@
 		return(DB_SUCCESS);
 	}
 
-	if (!srv_read_only_mode) {
+	if (!srv_read_only_mode && !srv_apply_log_only) {
 		/* Shutdown the FTS optimize sub system. */
 		fts_optimize_start_shutdown();
 
--- a/storage/innobase/sync/sync0arr.cc
+++ b/storage/innobase/sync/sync0arr.cc
@@ -42,6 +42,7 @@
 #include "lock0lock.h"
 #include "srv0srv.h"
 #include "ha_prototypes.h"
+#include "xb0xb.h"
 
 /*
 			WAIT ARRAY
@@ -899,6 +900,13 @@
 	ibool		fatal = FALSE;
 	double		longest_diff = 0;
 
+	if (srv_rebuild_indexes) {
+
+		/* Avoid long semaphore waits when rebuilding indexes */
+
+		return(FALSE);
+	}
+
 	/* For huge tables, skip the check during CHECK TABLE etc... */
 	if (fatal_timeout > SRV_SEMAPHORE_WAIT_EXTENSION) {
 		return(FALSE);
--- a/storage/innobase/trx/trx0rseg.cc
+++ b/storage/innobase/trx/trx0rseg.cc
@@ -121,9 +121,11 @@
 
 	mutex_free(&rseg->mutex);
 
+	if (!srv_apply_log_only) {
 	/* There can't be any active transactions. */
 	ut_a(UT_LIST_GET_LEN(rseg->update_undo_list) == 0);
 	ut_a(UT_LIST_GET_LEN(rseg->insert_undo_list) == 0);
+	}
 
 	for (undo = UT_LIST_GET_FIRST(rseg->update_undo_cached);
 	     undo != NULL;
--- a/storage/innobase/trx/trx0sys.cc
+++ b/storage/innobase/trx/trx0sys.cc
@@ -1185,18 +1185,21 @@
 	trx_purge_sys_close();
 
 	/* Free the double write data structures. */
-	buf_dblwr_free();
+	if (buf_dblwr)
+		buf_dblwr_free();
 
 	mutex_enter(&trx_sys->mutex);
 
 	ut_a(UT_LIST_GET_LEN(trx_sys->ro_trx_list) == 0);
 
+	if (!srv_apply_log_only) {
 	/* Only prepared transactions may be left in the system. Free them. */
 	ut_a(UT_LIST_GET_LEN(trx_sys->rw_trx_list) == trx_sys->n_prepared_trx);
 
 	while ((trx = UT_LIST_GET_FIRST(trx_sys->rw_trx_list)) != NULL) {
 		trx_free_prepared(trx);
 	}
+	}
 
 	/* There can't be any active transactions. */
 	for (i = 0; i < TRX_SYS_N_RSEGS; ++i) {
@@ -1223,10 +1226,12 @@
 		UT_LIST_REMOVE(view_list, trx_sys->view_list, prev_view);
 	}
 
+	if (!srv_apply_log_only) {
 	ut_a(UT_LIST_GET_LEN(trx_sys->view_list) == 0);
 	ut_a(UT_LIST_GET_LEN(trx_sys->ro_trx_list) == 0);
 	ut_a(UT_LIST_GET_LEN(trx_sys->rw_trx_list) == 0);
 	ut_a(UT_LIST_GET_LEN(trx_sys->mysql_trx_list) == 0);
+	}
 
 	mutex_exit(&trx_sys->mutex);
 
@@ -1247,6 +1252,10 @@
 {
 	ulint	total_trx = 0;
 
+	if (srv_apply_log_only) {
+		return(0);
+	}
+
 	mutex_enter(&trx_sys->mutex);
 
 	total_trx = UT_LIST_GET_LEN(trx_sys->rw_trx_list)
--- a/storage/innobase/trx/trx0trx.cc
+++ b/storage/innobase/trx/trx0trx.cc
@@ -531,9 +531,9 @@
 
 			if (srv_force_recovery == 0) {
 
-				trx->state = TRX_STATE_PREPARED;
-				trx_sys->n_prepared_trx++;
-				trx_sys->n_prepared_recovered_trx++;
+				/* XtraBackup should rollback prepared XA
+				transactions */
+				trx->state = TRX_STATE_ACTIVE;
 			} else {
 				fprintf(stderr,
 					"InnoDB: Since innodb_force_recovery"
@@ -599,14 +599,13 @@
 			" was in the XA prepared state.\n", trx->id);
 
 		if (srv_force_recovery == 0) {
-			if (trx_state_eq(trx, TRX_STATE_NOT_STARTED)) {
-				trx_sys->n_prepared_trx++;
-				trx_sys->n_prepared_recovered_trx++;
-			} else {
+			if (!trx_state_eq(trx, TRX_STATE_NOT_STARTED)) {
 				ut_ad(trx_state_eq(trx, TRX_STATE_PREPARED));
 			}
 
-			trx->state = TRX_STATE_PREPARED;
+			/* XtraBackup should rollback prepared XA
+			transactions */
+			trx->state = TRX_STATE_ACTIVE;
 		} else {
 			fprintf(stderr,
 				"InnoDB: Since innodb_force_recovery"
@@ -2221,7 +2220,8 @@
 		scenario where some undo generated by a transaction,
 		has XA stuff, and other undo, generated by the same
 		transaction, doesn't. */
-		trx->support_xa = thd_supports_xa(trx->mysql_thd);
+		trx->support_xa = trx->mysql_thd
+		    ? thd_supports_xa(trx->mysql_thd) : FALSE;
 
 		trx_start_low(trx);
 		/* fall through */
--- a/storage/innobase/include/ha_prototypes.h
+++ b/storage/innobase/include/ha_prototypes.h
@@ -41,6 +41,15 @@
 class Field;
 struct fts_string_t;
 
+/****************************************************************//**
+Update log_checksum_algorithm_ptr with a pointer to the function corresponding
+to a given checksum algorithm. */
+UNIV_INTERN
+void
+innodb_log_checksum_func_update(
+/*============================*/
+	ulint	algorithm);	/*!< in: algorithm */
+
 /*********************************************************************//**
 Wrapper around MySQL's copy_and_convert function.
 @return	number of bytes copied to 'to' */
--- a/sql/sql_yacc.yy
+++ b/sql/sql_yacc.yy
@@ -26,8 +26,6 @@
 ** The type will be void*, so it must be  cast to (THD*) when used.
 ** Use the YYTHD macro for this.
 */
-#define YYPARSE_PARAM yythd
-#define YYLEX_PARAM yythd
 #define YYTHD ((THD *)yythd)
 #define YYLIP (& YYTHD->m_parser_state->m_lip)
 #define YYPS (& YYTHD->m_parser_state->m_yacc)
@@ -85,7 +83,7 @@
     ulong val= *(F);                          \
     if (my_yyoverflow((B), (D), &val))        \
     {                                         \
-      yyerror((char*) (A));                   \
+      yyerror(yythd, (char*) (A));            \
       return 2;                               \
     }                                         \
     else                                      \
@@ -183,7 +181,7 @@
   to abort from the parser.
 */
 
-void MYSQLerror(const char *s)
+void MYSQLerror(void *yythd, const char *s)
 {
   THD *thd= current_thd;
 
@@ -1031,7 +1029,9 @@
 bool my_yyoverflow(short **a, YYSTYPE **b, ulong *yystacksize);
 %}
 
-%pure_parser                                    /* We have threads */
+%pure-parser                                    /* We have threads */
+%parse-param { void *yythd }
+%lex-param { void *yythd }
 /*
   Currently there are 161 shift/reduce conflicts.
   We should not introduce new conflicts any more.
